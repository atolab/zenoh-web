<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>zenoh - The Zero Overhead, Pub/Sub, Store, Query, and Compute Protocol.</title><link>/</link><description>Recent content on zenoh - The Zero Overhead, Pub/Sub, Store, Query, and Compute Protocol.</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Thu, 09 Jun 2022 00:00:00 +0000</lastBuildDate><atom:link href="/index.xml" rel="self" type="application/rss+xml"/><item><title>What is zenoh?</title><link>/docs/overview/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/overview/</guid><description>With the steady increase in the number of network connected devices we are experiencing a new level of heterogeneity with respect to computing, storage and communication capabilities, as well as new challenges with respect to the scale at which data is produced and needs to be consumed.
Additionally, for performance, efficiency and privacy reasons, there is an increasing desire to keep the data processing as close as possible to the source, while at the same time not hindering access to geographically remote applications.</description></item><item><title>Key concepts</title><link>/docs/getting-started/key-concepts/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/getting-started/key-concepts/</guid><description>Deployment units zenoh provides 3 kinds of deployment units: peers, clients and routers.
peer application A user application using a zenoh API and able to: Communicate with other peers over a complete graph topology. Communicate with other peers over connected graph topology. Communicate across the Internet through zenoh routers. client application A user application using a zenoh API and that connects to a single zenoh router (or a single peer) to communicate with the rest of the system.</description></item><item><title>Installation</title><link>/docs/getting-started/installation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/getting-started/installation/</guid><description>To get up and running with zenohyou will have to install the router and then get hold of the API you would like to use to write your applications.
Installing the zenoh router The zenoh router (a.k.a. zenohd) and its plugins are currently available as a pre-built binaries for various platforms. All release packages can be downloaded from:
https://download.eclipse.org/zenoh/zenoh/latest/ Each sub-directory has the name of the Rust target. See the platforms each target corresponds to on https://doc.</description></item><item><title>Zenoh Slides, Videos, Papers and More</title><link>/media/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/media/</guid><description>Slides Zenoh: The Edge Data Fabric Zenoh: Coding Lab Videos Zenoh: The Edge Data Fabric</description></item><item><title>For a Quick Test using Docker</title><link>/docs/getting-started/quick-test/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/getting-started/quick-test/</guid><description>This page describe how to perform a quick test of zenoh, using a Docker image.
Run zenoh router in a Docker container The zenoh router is also available in a Docker image. You can deploy a single instance on your local host just running:
docker run --init -p 7447:7447/tcp -p 8000:8000/tcp eclipse/zenoh The ports used by zenoh are the following:
7447/tcp : the zenoh protocol via TCP 8000/tcp : the zenoh REST API ⚠️ WARNING ⚠️: Docker doesn&amp;rsquo;t support UDP multicast between a container and its host (see cases moby/moby#23659, moby/libnetwork#2397 or moby/libnetwork#552).</description></item><item><title>Your First zenoh app</title><link>/docs/getting-started/first-app/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/getting-started/first-app/</guid><description>Getting started with zenoh is quite straightforward. Below we will show you how to create a simple telemetry application. Let&amp;rsquo;s assume that we have some sensor, say a temperature sensor, and we want to store this temperature into a zenoh storage. Later on, we want to retrieve this temperature from the zenoh storage.
Before cranking some code, let&amp;rsquo;s define some terminology.
zenohdeals with keys/valueswhere each key is a pathand is associated to a value.</description></item><item><title>Troubleshooting</title><link>/docs/getting-started/troubleshooting/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/getting-started/troubleshooting/</guid><description>Activate logging Activating the zenoh logging can provide useful information for any troubleshooting. The zenoh router (zenohd) and all the zenoh APIs (except zenoh-pico) are developped with a Rust code base. Logging is controlled via the RUST_LOG environment variable that can typically be defined with the desired logging level amongst:
error - this is the default level if RUST_LOG is not defined warn info debug trace off - to disable all logging More advanced logging directives can be defined via the RUST_LOG.</description></item><item><title>Abstractions</title><link>/docs/manual/abstractions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/manual/abstractions/</guid><description>Zenoh is a distributed service to define, manage and operate on key/value spaces.
The key abstractions at the core of zenoh are the following:
Key Zenoh uses paths as keys. In all zenoh documentations, &amp;ldquo;key&amp;rdquo; and &amp;ldquo;path&amp;rdquo; are synonym.
Path A set of strings separated by '/' , as in a filesystem path. A Path cannot contain any '*' character.
Examples of paths: /demo/example/test , /com/adlink/building/fr/floor/1/office/2 &amp;hellip;
A path can be absolute (i.</description></item><item><title>Configuration</title><link>/docs/manual/configuration/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/manual/configuration/</guid><description>From version 0.6 of zenoh, configuration has changed in major ways. This page will take you throuh the new behaviour of configuration, whether you&amp;rsquo;re using Zenoh as a library, or as an executable through zenohd.
Configuring zenohd There are 3 ways to configure zenohd, which may be used in any combination:
using a configuration file, through the command line arguments, and by putting values on the configuration through the adminspace.</description></item><item><title>Zenoh plugins</title><link>/docs/manual/plugins/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/manual/plugins/</guid><description>The zenoh router (zenohd executable) supports the loading of plugins at start-up.
A zenoh plugin is a library that can be loaded by the zenoh router at start-up. It shares a runtime with it, allowing the plugin to use the regular zenoh rust APIs with the same peer ID.
Zenoh already provides the following plugins in its default repository:
the REST plugin: providing the zenoh REST API the Storages plugin: providing management of storages and backends Before v0.</description></item><item><title>REST plugin</title><link>/docs/manual/plugin-http/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/manual/plugin-http/</guid><description>The REST plugin provides access to the zenoh REST API.
Library name: zplugin_rest
Startup arguments (added to zenoh router&amp;rsquo;s startup arguments):
--rest-http-port=[PORT] : The REST plugin&amp;rsquo;s http port (default: 8000)</description></item><item><title>Storages plugin</title><link>/docs/manual/plugin-storages/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/manual/plugin-storages/</guid><description>The Storages plugin provides the management of Backends and Storages.
It allows you at runtime to dynamically add/remove backends and storages. More details in Zenoh backends chapter.
When adding a backend, a short name of the backend library can be provided instead of the complete path to the library file. In such case the Storages plugin will search and load the library file with such name:
on Unix/Linux: libzbackend_&amp;lt;name&amp;gt;.so on macOS: libzbackend_&amp;lt;name&amp;gt;.</description></item><item><title>QUIC transport</title><link>/docs/manual/quic/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/manual/quic/</guid><description>Zenoh supports QUIC as a transport protocol.
As you may already know, QUIC is a UDP-based, stream-multiplexing, encrypted transport protocol. It natively embedes TLS for encryption, authentication and confidentiality.
As of today, the only supported TLS authentication mode in zenoh is server-authentication: clients validate the server TLS certificate but not the other way around. That is, the same way of operating in the web where the web browsers validate the identity of the server via means of the TLS certificate.</description></item><item><title>TLS authentication</title><link>/docs/manual/tls/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/manual/tls/</guid><description>Zenoh supports TLS as a transport protocol. As of today, the only supported TLS authentication mode is server-authentication: clients validate the server TLS certificate but not the other way around. That is, the same way of operating in the web where the web browsers validate the identity of the server via means of the TLS certificate.
TLS certificates creation In order to use TLS as a transport protocol, we need first to create the TLS certificates.</description></item><item><title>User-Password authentication</title><link>/docs/manual/user-password/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/manual/user-password/</guid><description>Zenoh supports basic user-password authentication. Clients and peers can use user and password for authentication against a router or a peer. The configuration of credentials is done via a configuration file defining certain zenoh properties.
Client configuration The required zenoh properties for basic user-password authentication for a client are user and password. A configuration file for a client would be:
user=clientusername password=clientpassword When using such configuration, the client will use the provided user and password to authenticate against any peer or router.</description></item><item><title>Zenoh backends and storages</title><link>/docs/manual/backends/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/manual/backends/</guid><description>In zenoh a backend is a storage technology.
Concretely, it&amp;rsquo;s a software library providing implementation of Storages. It usualy leverage a third-party technology (e.g. InfluxDB, SQLite, PostgreSQL&amp;hellip;) to store the keys/values published in zenoh.
The backends and storages are managed in each zenoh router by its Storages plugin.
Backends management The backends provided by a zenoh router can be managed via the admin space using zenoh PUT/GET/DELETE operations on such Path:</description></item><item><title>List of backends</title><link>/docs/manual/backends-list/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/manual/backends-list/</guid><description>Here is the list of the available backends:
Backend Description Github repo &amp;amp; doc Memory In-memory storages (simple hashmap) see below InfluxDB Storages in InfluxDB databases. eclipse-zenoh/zenoh-backend-influxdb File System Storages on local files system, each key/value in a file. eclipse-zenoh/zenoh-backend-filesystem Memory Backend A backend storing paths/values into an in-memory hashmap.
The memory backend implementation is not provided by a backend library but is embeded within the Storages plugin itself.</description></item><item><title>API documentations</title><link>/docs/apis/apis/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/apis/apis/</guid><description>All the client APIs documentations are avaliable on Read the Docs:
Rust https://zenoh-rust.readthedocs.io/
C https://zenoh-c.readthedocs.io/
Python https://zenoh-python.readthedocs.io/
REST API Zenoh also offers a REST API via the zenoh-rest plugin. When starting zenoh with default options, this REST plugin is automatically started on port 8000 and ready to answer HTTP requests.
The full zenoh key/value space is accessible via this REST API, including the Admin Space under the '/@'prefix.
GET Binds to the get(selector) operation on zenoh.</description></item><item><title>A Year Full of Zenoh</title><link>/blog/2020-01-01-zenohtude/</link><pubDate>Wed, 01 Jan 2020 00:00:00 +0000</pubDate><guid>/blog/2020-01-01-zenohtude/</guid><description>First of all we would like to take a moment to wish all of you a 2020 filled with joy, health, peace and success.
This year marks a very important landmark for us. After having kicked-off the Eclipse Edge Native working group, last December, we are bringing zenoh to Eclipse and are starting to work a Rust rewrite of the zenoh router. As part for the rewrite we have just about to complete a review of the zenoh protocol and will be updating the specification accordingly in the weeks to come.</description></item><item><title>Zenoh Tidings</title><link>/blog/2020-06-29-zenoh-tidings/</link><pubDate>Tue, 30 Jun 2020 00:00:00 +0000</pubDate><guid>/blog/2020-06-29-zenoh-tidings/</guid><description>In our last blog we had announced a rewrite of zenoh in Rust. The wrote the first version of zenoh in OCaml, a super-neat ML-derived functional programming language. OCaml allowed us to experiment very quickly and have good performances. Yet, one of the major feedback we were receiving from the community was that few people knew this programming language and this was limiting contributions. Beside, we had the desire to make zenoh even faster and smaller.</description></item><item><title>Zenoh Aithusa Hatched Out!</title><link>/blog/2020-10-08-aithusa/</link><pubDate>Thu, 08 Oct 2020 00:00:00 +0000</pubDate><guid>/blog/2020-10-08-aithusa/</guid><description>We have been waiting this very moment for several months. Months of patient dedication, months of hard and creative work. Months in which each and every member of the zenoh team has made his and her best to give our little dragon all it needed to succed in the complicated world of Internet Scale Protocols.
Today, at about 11.00 Paris Time Zenoh Aithusa Hatched Out!
Aithusa is the code-name for the first release of our Rust-based zenoh infrastructure, A supercharged of new features and improvements, including better performance, improved network scheduling, ROS2 integration, and DDS Plugin.</description></item><item><title>Minimizing Discovery Overhead in ROS2</title><link>/blog/2021-03-23-discovery/</link><pubDate>Tue, 23 Mar 2021 00:00:00 +0000</pubDate><guid>/blog/2021-03-23-discovery/</guid><description>The amount of discovery traffic generated by ROS2 is a problem that has received an increasing attention in the community. The discovery overhead issue becomes extremely severe when running over wireless technologies, such as WiFi, and in particular in combination with more complex robots, robot swarms and tele-operation. The ROS2 Discovery Service has been proposed as a way to alleviate the problem, not necessarily to solve it.
In the reminder of this post I&amp;rsquo;ll explain the essence of problem, remind what was tried in the past and unveils a Zenoh based solution that (1) drastically reduces DDS discovery overhead &amp;ndash; from 97% to 99,9% in tested scenarios, (2) allows for peer-to-peer communication when useful, (3) enables efficient Internet-scale routing when necessary, and (3) does not require any changes to your existing ROS2 systems.</description></item><item><title>Integrating ROS2 with Eclipse zenoh</title><link>/blog/2021-04-28-ros2-integration/</link><pubDate>Wed, 28 Apr 2021 00:00:00 +0000</pubDate><guid>/blog/2021-04-28-ros2-integration/</guid><description>In our previous blog we demonstrated how the zenoh bridge for DDS allows to (1) bridge DDS communications through zenoh, and (2) reduce by up to 99.97% the discovery traffic between the nodes.
The previous blog was focusing on demonstrating the advantages of using zenoh as the mean for ROS2-to-ROS2 communication over wireless technologies. In this blog, we’ll go one step further and will demonstrate how you can easily write native zenoh applications —meaning that has no dependencies on ROS2 — and seamlessly interact with ROS2 applications.</description></item><item><title>Zenoh Reliability, Scalability and Congestion Control</title><link>/blog/2021-06-14-zenoh-reliability/</link><pubDate>Mon, 14 Jun 2021 00:00:00 +0000</pubDate><guid>/blog/2021-06-14-zenoh-reliability/</guid><description>Providing many to many reliable communications over a wide area network is challenging. This may even be an understatement, as theoretically, even simple point to point reliable communication over asynchronous channels requires either infinite amount of memory or giving up progress… but guess what, many real systems can’t afford neither of those restrictions. Thus, trade-offs need to be made regarding reliability for the system to work, scale smoothly and have sufficiently strong guarantees.</description></item><item><title>Zenoh overhead: a story from our community</title><link>/blog/2021-07-05-zenoh-overhead/</link><pubDate>Mon, 05 Jul 2021 00:00:00 +0000</pubDate><guid>/blog/2021-07-05-zenoh-overhead/</guid><description>Zenoh&amp;rsquo;s webpage states that zenoh has a minimal wire overhead of 5 bytes. This is the result of careful considerations in the zenoh design: from using Variable Length Encoding (VLE), to efficient mapping of resource keys and automatic batching.
If you are intrigued about this and want to know more, rest assured that you are not alone. In fact, the minimal overhead aspect of zenoh attracted a lot of attention and curiosity in our community that led to some interesting discussions on zenoh&amp;rsquo;s gitter channel.</description></item><item><title>Zenoh performance: a stroll in Rust async wonderland</title><link>/blog/2021-07-13-zenoh-performance-async/</link><pubDate>Tue, 13 Jul 2021 00:00:00 +0000</pubDate><guid>/blog/2021-07-13-zenoh-performance-async/</guid><description>Since its very first public release, zenoh provided impressive and easily accessible performances (see here). But instead of resting on laurels, the zenoh team has been relentlessly working on further improving them.
As a result of this work, we are happy to announce that zenoh delivers at least twice the performances than before:
more than 3.5M msg/s with 8 bytes payload, more than 45 Gb/s with 1 Megabyte payload, a latency as little as 35 µsec in backlogged scenarios.</description></item><item><title>Indy Autonomous Challenge (IAC): Experiences from the Trenches</title><link>/blog/2021-09-28-iac-experiences-from-the-trenches/</link><pubDate>Tue, 28 Sep 2021 00:00:00 +0000</pubDate><guid>/blog/2021-09-28-iac-experiences-from-the-trenches/</guid><description>The Indy Autonomous Challenge is a competition of autonomous racecars between teams of university students. Even if fully autonomous, each car needs to communicate with its team’s base station to report telemetry, status and to receive commands, such as emergency stop. The communication infrastructure between the cars and the base stations leverages CISCO Ultra-Reliable Wireless Backhaul (CURWB). As all cars share the same infrastructure, some limitations have been imposed on teams in terms of packet rates and bandwidth usage.</description></item><item><title>Zenoh goes embedded with zenoh-pico</title><link>/blog/2021-10-04-zenoh-pico-guide/</link><pubDate>Mon, 04 Oct 2021 00:00:00 +0000</pubDate><guid>/blog/2021-10-04-zenoh-pico-guide/</guid><description>In this post, we will introduce zenoh-pico, a lightweight implementation of Zenoh APIs in C, fully compatible with its Rust counterpart.
As a result of this work, we are happy to announce that we successfully deployed and tested Zenoh in Zephyr (reel_board and nucleo-f767zi) and Arduino (ESP32) compatible boards, with initial results showcasing a quite remarkable performance within the microcontrollers landscape:
Memory footprint of only ~37KB (ESP32), ~60KB (nucleo-f767zi), and ~96KB (reel_board).</description></item><item><title>ROS 2 and microcontrollers integration via Zenoh-pico</title><link>/blog/2021-11-09-ros2-zenoh-pico/</link><pubDate>Tue, 09 Nov 2021 00:00:00 +0000</pubDate><guid>/blog/2021-11-09-ros2-zenoh-pico/</guid><description>In a previous blog, we showed how you can easily write native Zenoh applications and seamlessly interact with ROS 2 applications. This was exemplified by developing a native Zenoh teleoperation application to control a ROS 2 powered robot, namely a turtlebot or its simulation counterpart turtlesim, from anywhere in the world. In this blog, we will go one step further by trying to make it cool and fun &amp;ndash; together with a bit of nostalgia.</description></item><item><title>DragonBotOne Egg Hatching with Zenoh and Zenoh-Pico</title><link>/blog/2022-02-08-dragonbot/</link><pubDate>Tue, 08 Feb 2022 00:00:00 +0000</pubDate><guid>/blog/2022-02-08-dragonbot/</guid><description>In previous blogs (1)(2), we showed how you can easily develop native Zenoh applications and seamlessly integrate them with ROS2 applications by using Zenoh bridge for DDS. In particular, this was successfully exemplified by using a TurtleBot, a well-known, low-cost, personal robot kit with open-source software and hardware.
In this blog, we go one step further to show how you can bring Zenoh down to the TurtleBot’s microcontroller and control it from a different geographic location via a Zenoh infrastructure.</description></item><item><title>Mobility, Latency and Energy saving</title><link>/blog/2022-03-30-zenoh-mobility/</link><pubDate>Wed, 30 Mar 2022 00:00:00 +0000</pubDate><guid>/blog/2022-03-30-zenoh-mobility/</guid><description>Connected cars, smart factories, swarms of robots… More and more applications need device mobility and require low latency for local device to device communications. With the increases in energy costs and its constrained availability, there is an increasing necessity to optimize data paths and to avoid unnecessary data transmissions – as just for clarity, communications takes the lion share in energy consumption when compared to computation.
Cloud centric architectures are energetically greedy and offer poor latency.</description></item><item><title>A Performance Evaluation on Rust Asynchronous Frameworks</title><link>/blog/2022-04-14-rust-async-eval/</link><pubDate>Thu, 14 Apr 2022 00:00:00 +0000</pubDate><guid>/blog/2022-04-14-rust-async-eval/</guid><description>As we previously mentioned in this blog post, Zenoh is written in Rust and leverages the async features to achieve high performance and scalability. At the present stage, we rely on the async_std framework – a decision that we took after a careful performance evaluation of the frameworks available in late 2019. This framework has proven to be quite effective, allowing Zenoh to reach more than 4M msg/s with 8 bytes payload and over 45Gb/s with 1MiB payload while keeping latency of ~30µS.</description></item><item><title>Zenoh-Pico: Above and Beyond</title><link>/blog/2022-06-99-zenoh-pico-above-and-beyond/</link><pubDate>Thu, 09 Jun 2022 00:00:00 +0000</pubDate><guid>/blog/2022-06-99-zenoh-pico-above-and-beyond/</guid><description>In a previous blog post, we introduced Zenoh-Pico, an implementation of Zenoh for microcontrollers and embedded devices, along with a preliminary performance results and its integration on off-the-shelf robots (by bridging both legacy ROS2+DDS and Zenoh systems or by making it a full-fledged Zenoh system).
In this post, we will dive deeper on Zenoh-Pico, show, how Zenoh-Pico is capable of:
exchanging close to 2.5M msg/s for small payloads, and over 25 Gbps for larger messages, achieving end-to-end latency (i.</description></item><item><title>The zenoh Community</title><link>/community/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/community/</guid><description>Communication The zenoh community is most readily found on its gitter channel, where you&amp;rsquo;re welcome to ask questions, report problems, or pitch ideas.
Issues Github is used for tracking issues.
If your issue is related to the zenoh protocol, the infrastructure or the REST API, the primary location is https://github.com/eclipse-zenoh/zenoh/issues.
If your issue is related to an API, please use the Github issues related to this API:
Python API Java API Go API If you&amp;rsquo;re a zenoh user, you&amp;rsquo;re highly encouraged to keep an eye on these issues and jump in on the discussions, to help us understand how design tradeoffs might affect you.</description></item><item><title>Third-party crates</title><link>/community/third-party/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/community/third-party/</guid><description>Currently the futures, zenoh-core, zenoh-service, and zenoh-proto crates provide the foundation for the Tokio ecosystem. There&amp;rsquo;s a growing set of crates outside of Tokio itself, however, filling in more functionality!
zenoh-curl is an HTTP client library backed by the libcurl C library. zenoh-timer is a timer library providing finer-grained control over timers and helpful timeout facilities over the types in zenoh-core. zenoh-tls is a library for TLS streams backed by native-tls.</description></item><item><title>Zenoh Adopters</title><link>/adopters/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/adopters/</guid><description>Below is a list of companies, research institutes and foundations that adopted, supported or contributed to zenoh. If you cannot find your logo post a message on the zenoh&amp;rsquo;s gitter channel and we&amp;rsquo;ll add it right away.</description></item></channel></rss>
<!doctype html><html lang=en><head><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.png><meta name=msapplication-TileImage content="/safari-pinned-tab.png"><meta name=msapplication-TileColor content="#7da7d8"><meta name=theme-color content="#7da7d8"><meta charset=utf-8><meta name=description content="Eclipse Zenoh, unify data in motion, data at rest and computations."><meta name=keywords content="pub/sub,query,geo distributed storage,Rust,protocol,DDS,MQTT,Edge,IoT,MEC"><meta name=author content="The Zenoh Team"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta http-equiv=x-ua-compatible content="ie=edge"><link rel=stylesheet href=../../css/bootstrap-reboot.css><link rel=stylesheet href=../../css/bootstrap.css><link rel=stylesheet href=../../css/font-awesome.min.css><link rel=stylesheet href=../../css/ato.css><link rel=stylesheet href=../../css/syntax.css><link rel=alternate type=application/rss+xml href=../../blog/index.xml><title>Zenoh performance: a stroll in Rust async wonderland · Zenoh - pub/sub, geo distributed storage, query</title></head><body><header class="navbar-expand navbar-dark d-flex flex-column flex-md-row align-items-md-center ato-navbar"><div class="d-flex flex-row justify-content-between pl-2 pr-2"><a class=navbar-brand href=../../><img src=../../img/zenoh-dragon-bg-150x163.png class=align-middle alt></a>
<button class="btn btn-link d-md-none p-0" type=button data-toggle=collapse data-target=#ato-nav aria-controls=ato-nav aria-expanded=false aria-label="Toggle navigation"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 30 30" width="30" height="30" focusable="false"><title>Menu</title><path stroke="#fff" stroke-width="2" stroke-linecap="round" stroke-miterlimit="10" d="M4 7h22M4 15h22M4 23h22"/></svg></button></div><div class="ato-links collapse pl-4 pl-md-0" id=ato-nav><ul class="navbar-nav flex-column flex-md-row"><li class=nav-item><a class=nav-link href=../../>Home</a></li><li class=nav-item><a class=nav-link href=../../docs/getting-started/first-app/>Documentation</a></li><li class=nav-item><a class=nav-link href=../../usecases/>Use Cases</a></li><li class=nav-item><a class=nav-link href=../../community/>Community</a></li><li class=nav-item><a class=nav-link href=../../adopters/>Adopters</a></li><li class=nav-item><a class=nav-link href=../../media/>Media</a></li><li class=nav-item><a class="nav-link active" href=../../blog/2024-01-31-zenoh-flow-getting-started/>Blog</a></li></ul></div><ul class="navbar-nav flex-row ml-md-auto d-none d-md-flex"><li class=nav-item><a class="nav-link p-2" href=https://github.com/eclipse-zenoh/zenoh target=_blank rel=noopener aria-label=GitHub><svg class="navbar-nav-svg" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 512 499.36" focusable="false"><title>GitHub</title><path d="M256 0C114.64.0.0 114.61.0 256c0 113.09 73.34 209 175.08 242.9 12.8 2.35 17.47-5.56 17.47-12.34.0-6.08-.22-22.18-.35-43.54-71.2 15.49-86.2-34.34-86.2-34.34-11.64-29.57-28.42-37.45-28.42-37.45-23.27-15.84 1.73-15.55 1.73-15.55 25.69 1.81 39.21 26.38 39.21 26.38 22.84 39.12 59.92 27.82 74.5 21.27 2.33-16.54 8.94-27.82 16.25-34.22-56.84-6.43-116.6-28.43-116.6-126.49.0-27.95 10-50.8 26.35-68.69-2.63-6.48-11.42-32.5 2.51-67.75.0.0 21.49-6.88 70.4 26.24a242.65 242.65.0 01128.18.0c48.87-33.13 70.33-26.24 70.33-26.24 14 35.25 5.18 61.27 2.55 67.75 16.41 17.9 26.31 40.75 26.31 68.69.0 98.35-59.85 120-116.88 126.32 9.19 7.9 17.38 23.53 17.38 47.41.0 34.22-.31 61.83-.31 70.23.0 6.85 4.61 14.81 17.6 12.31C438.72 464.97 512 369.08 512 256.02 512 114.62 397.37.0 256 0z" fill="currentcolor" fill-rule="evenodd"/></svg></a></li><li class=nav-item><a class="nav-link p-2" href=https://twitter.com/zettascaletech target=_blank rel=noopener aria-label=Twitter><svg class="navbar-nav-svg" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 512 416.32" focusable="false"><title>Twitter</title><path d="M160.83 416.32c193.2.0 298.92-160.22 298.92-298.92.0-4.51.0-9-.2-13.52A214 214 0 00512 49.38a212.93 212.93.0 01-60.44 16.6 105.7 105.7.0 0046.3-58.19 209 209 0 01-66.79 25.37 105.09 105.09.0 00-181.73 71.91 116.12 116.12.0 002.66 24c-87.28-4.3-164.73-46.3-216.56-109.82A105.48 105.48.0 0068 159.6a106.27 106.27.0 01-47.53-13.11v1.43a105.28 105.28.0 0084.21 103.06 105.67 105.67.0 01-47.33 1.84 105.06 105.06.0 0098.14 72.94A210.72 210.72.0 0125 370.84a202.17 202.17.0 01-25-1.43 298.85 298.85.0 00160.83 46.92" fill="currentcolor"/></svg></a></li><li class=nav-item><a class="nav-link p-2" href=https://discord.gg/2GJ958VuHs target=_blank rel=noopener aria-label=Discord><svg class="navbar-nav-svg" xmlns="http://www.w3.org/2000/svg" focusable="false"><title>Discord</title><path fill="currentcolor" d="M13.545 2.907a13.227 13.227.0 00-3.257-1.011.05.05.0 00-.052.025c-.141.25-.297.577-.406.833a12.19 12.19.0 00-3.658.0 8.258 8.258.0 00-.412-.833.051.051.0 00-.052-.025c-1.125.194-2.22.534-3.257 1.011a.041.041.0 00-.021.018C.356 6.024-.213 9.047.066 12.032c.001.014.01.028.021.037a13.276 13.276.0 003.995 2.02.05.05.0 00.056-.019c.308-.42.582-.863.818-1.329a.05.05.0 00-.01-.059.051.051.0 00-.018-.011 8.875 8.875.0 01-1.248-.595.05.05.0 01-.02-.066.051.051.0 01.015-.019c.084-.063.168-.129.248-.195a.05.05.0 01.051-.007c2.619 1.196 5.454 1.196 8.041.0a.052.052.0 01.053.007c.08.066.164.132.248.195a.051.051.0 01-.004.085 8.254 8.254.0 01-1.249.594.05.05.0 00-.03.03.052.052.0 00.003.041c.24.465.515.909.817 1.329a.05.05.0 00.056.019 13.235 13.235.0 004.001-2.02.049.049.0 00.021-.037c.334-3.451-.559-6.449-2.366-9.106a.034.034.0 00-.02-.019zm-8.198 7.307c-.789.0-1.438-.724-1.438-1.612.0-.889.637-1.613 1.438-1.613.807.0 1.45.73 1.438 1.613.0.888-.637 1.612-1.438 1.612zm5.316.0c-.788.0-1.438-.724-1.438-1.612.0-.889.637-1.613 1.438-1.613.807.0 1.451.73 1.438 1.613.0.888-.631 1.612-1.438 1.612z"/></svg></a></li><li class=nav-item><a class="nav-link p-2" href=https://www.youtube.com/channel/UCslbiyiqgOAPMjCrPWIfQ5Q target=_blank rel=noopener aria-label=Youtube><svg class="navbar-nav-svg" xmlns="http://www.w3.org/2000/svg" focusable="false"><title>Youtube</title><path fill="currentcolor" d="M8.051 1.999h.089c.822.003 4.987.033 6.11.335a2.01 2.01.0 011.415 1.42c.101.38.172.883.22 1.402l.01.104.022.26.008.104c.065.914.073 1.77.074 1.957v.075c-.001.194-.01 1.108-.082 2.06l-.008.105-.009.104c-.05.572-.124 1.14-.235 1.558a2.007 2.007.0 01-1.415 1.42c-1.16.312-5.569.334-6.18.335h-.142c-.309.0-1.587-.006-2.927-.052l-.17-.006-.087-.004-.171-.007-.171-.007c-1.11-.049-2.167-.128-2.654-.26a2.007 2.007.0 01-1.415-1.419c-.111-.417-.185-.986-.235-1.558L.09 9.82.082 9.716A31.4 31.4.0 010 7.68v-.123c.002-.215.01-.958.064-1.778l.007-.103.003-.052.008-.104.022-.26.01-.104c.048-.519.119-1.023.22-1.402a2.007 2.007.0 011.415-1.42c.487-.13 1.544-.21 2.654-.26l.17-.007.172-.006.086-.003.171-.007A99.788 99.788.0 017.858 2h.193zM6.4 5.209v4.818l4.157-2.408L6.4 5.209z"/></svg></a></li></ul><script async src="https://www.googletagmanager.com/gtag/js?id=G-PBD6MS51QL"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-PBD6MS51QL")</script><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":""},"articleSection":"blog","name":"Zenoh performance: a stroll in Rust async wonderland","headline":"Zenoh performance: a stroll in Rust async wonderland","datePublished":"2021-07-13 00:00:00 \u002b0000 UTC","dateModified":"2021-07-13 00:00:00 \u002b0000 UTC","url":"\/blog\/2021-07-13-zenoh-performance-async\/","inLanguage":"en-US","author":"","creator":"","publisher":"","accountablePerson":"","copyrightHolder":"","copyrightYear":"131313","wordCount":"2046","keywords":[],"description":"13 July 2021 -- Paris."}</script></header><div class="container-fluid ato-blog"><div class="row flex-xl-nowrap"><div class="col-12 col-md-3 col-xl-2 ato-sidebar"><div class="ato-docs-toggle d-md-none p-0 d-flex ml-3 collapsed align-item-center"><h1 class=ato-title>Zenoh performance: a stroll in Rust async wonderland</h1><button class="btn btn-link" type=button data-toggle=collapse data-target=#ato-docs-nav aria-controls=ato-docs-nav aria-expanded=false aria-label="Toggle docs navigation"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 30 30" width="30" height="30" focusable="false"><title>Menu</title><path stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-miterlimit="10" d="M4 7h22M4 15h22M4 23h22"/></svg></button></div><nav class="ato-links collapse" id=ato-docs-nav><div class="ato-toc-item active"><p class=ato-toc-link>Blog Posts</p><ul class="nav ato-sidenav"><li><a href=../../blog/2024-01-31-zenoh-flow-getting-started/>Zenoh-Flow 0.6.0-rc: Getting Started</a></li><li><a href=../../blog/2023-10-03-zenoh-dragonite/>Zenoh Dragonite Took Off!</a></li><li><a href=../../blog/2023-07-17-s3-backend/>Zenoh Storage Gets a Boost: Empowering Storage with S3 Integration</a></li><li><a href=../../blog/2023-06-05-charmander2/>Zenoh Charmander Grows Stronger</a></li><li><a href=../../blog/2023-04-04-letsencrypt/>Securing Zenoh with LetsEncrypt: A Comprehensive Guide</a></li><li><a href=../../blog/2023-03-21-zenoh-vs-mqtt-kafka-dds/>Comparing the Performance of Zenoh, MQTT, Kafka, and DDS</a></li><li><a href=../../blog/2023-02-10-zenoh-flow/>Data Flow programming with Zenoh-Flow</a></li><li><a href=../../blog/2023-01-17-zenoh-wireshark/>The Blue Dragon meets the Wire’s Shark</a></li><li><a href=../../blog/2023-01-10-zenoh-charmander/>Zenoh Charmander is coming to town</a></li><li><a href=../../blog/2022-11-29-zenoh-alignment/>Keeping storages aligned in Zenoh</a></li><li><a href=../../blog/2022-09-30-zenoh-bahamut/>Zenoh Bahamut takes flight!</a></li><li><a href=../../blog/2022-08-12-zenoh-serial/>There is Land Besides IP: How to Cross It with Zenoh</a></li><li><a href=../../blog/2022-06-09-zenoh-pico-above-and-beyond/>Zenoh-Pico: Above and Beyond</a></li><li><a href=../../blog/2022-04-14-rust-async-eval/>A Performance Evaluation on Rust Asynchronous Frameworks</a></li><li><a href=../../blog/2022-03-30-zenoh-mobility/>Mobility, Latency and Energy saving</a></li><li><a href=../../blog/2022-02-08-dragonbot/>DragonBotOne Egg Hatching with Zenoh and Zenoh-Pico</a></li><li><a href=../../blog/2021-11-09-ros2-zenoh-pico/>ROS 2 and microcontrollers integration via Zenoh-pico</a></li><li><a href=../../blog/2021-10-04-zenoh-pico-guide/>Zenoh goes embedded with zenoh-pico</a></li><li><a href=../../blog/2021-09-28-iac-experiences-from-the-trenches/>Indy Autonomous Challenge (IAC): Experiences from the Trenches</a></li><li><a href=../../blog/2021-07-13-zenoh-performance-async/>Zenoh performance: a stroll in Rust async wonderland</a></li><li><a href=../../blog/2021-07-05-zenoh-overhead/>Zenoh overhead: a story from our community</a></li><li><a href=../../blog/2021-06-14-zenoh-reliability/>Zenoh Reliability, Scalability and Congestion Control</a></li><li><a href=../../blog/2021-04-28-ros2-integration/>Integrating ROS2 with Eclipse zenoh</a></li><li><a href=../../blog/2021-03-23-discovery/>Minimizing Discovery Overhead in ROS2</a></li><li><a href=../../blog/2020-10-08-aithusa/>Zenoh Aithusa Hatched Out!</a></li><li><a href=../../blog/2020-06-29-zenoh-tidings/>Zenoh Tidings</a></li><li><a href=../../blog/2020-01-01-zenohtude/>A Year Full of Zenoh</a></li></ul></div></nav></div><div class="d-none d-xl-block col-xl-2 ato-toc"><div class=section-nav><nav id=TableOfContents><ul><li><a href=#getting-ready>Getting ready</a></li><li><a href=#finding-the-hotspots>Finding the hotspots</a></li><li><a href=#heap-or-not-to-heap-stack-is-the-problem>Heap or not to heap? Stack is the problem</a></li><li><a href=#looking-at-the-results>Looking at the results</a><ul><li><a href=#peer-to-peer-communication>Peer-to-peer communication</a></li><li><a href=#routed-communication>Routed communication</a></li></ul></li><li><a href=#conclusions>Conclusions</a></li></ul></nav></div></div><main class="col-12 col-md-9 col-xl-8 py-md-3 pl-md-5 ato-content ato-docs"><h1 class=ato-title>Zenoh performance: a stroll in Rust async wonderland</h1><p class=ato-date>13 July 2021 -- Paris.</p><p>Since its very first public release, zenoh provided impressive and easily accessible performances (see <strong><a href=https://zenoh.io/blog/2020-06-29-zenoh-tidings/>here</a></strong>).
But instead of resting on laurels, the zenoh team has been relentlessly working on further improving them.</p><p>As a result of this work, we are happy to announce that zenoh delivers at least twice the performances than before:</p><ul><li>more than <strong>3.5M msg/s</strong> with 8 bytes payload,</li><li>more than <strong>45 Gb/s</strong> with 1 Megabyte payload,</li><li>a latency as little as <strong>35 µsec</strong> in backlogged scenarios.</li></ul><p>The reminder of this post will take you through the journey of zenoh profiling along with the nuts and bolts of Rust async programming.
If you are unfamiliar with Rust and you are just interested in the results, you can jump directly <strong><a href=#looking-at-the-results>here</a></strong>.</p><hr><h2 id=getting-ready>Getting ready</h2><p>As we previously wrote in this <strong><a href=https://zenoh.io/blog/2020-06-29-zenoh-tidings/>blog post</a></strong>, zenoh is purely written in <strong><a href=https://www.rust-lang.org/>Rust</a></strong> and leverages the <strong><a href=https://async.rs/>async</a></strong> features to achieve high performance and scalability.</p><p>Even though initial zenoh performances were already quite good, we weren’t completely happy about them. Some numbers didn’t sum up as expected and we were very puzzled about it: we knew that zenoh could deliver more. We had only to discover what was preventing us from getting there. So, during the last few months we have been relentlessly profiling zenoh and looking into its most deep and intimate internals.</p><p>The very first thing we did was to properly prepare our testing environment in such a way to get reproducible results. This is very important when profiling your code otherwise you risk to walk down the wrong path: there are plenty of external factors that may impact the performance of the code. If you are about to profile your code, we highly recommend you to follow this <strong><a href=https://easyperf.net/blog/2019/08/02/Perf-measurement-environment-on-Linux>guide</a></strong> that summarizes very well how to properly setup a Linux environment and how to get consistent results out of it.</p><p>The second thing was to have a thorough read of <strong><a href=https://nnethercote.github.io/perf-book/title-page.html>The Rust Performance Book</a></strong>. If you are developing in Rust like us, we recommend you to go through it since we found it really insightful for what concerns performance tips and tricks along with profiling techniques in Rust.
Another nice reference on how to write performant code in Rust can be found <strong><a href=http://likebike.com/posts/How_To_Write_Fast_Rust_Code.html>here</a></strong>.</p><h2 id=finding-the-hotspots>Finding the hotspots</h2><p>We started with identifying the hotspots in zenoh by generating flame-graphs with this <strong><a href=https://github.com/flamegraph-rs/flamegraph>tool</a></strong>. We were confident that flame-graphs were a good way to visualize which part of the code takes most of the time in zenoh. We were wrong.</p><p>We couldn’t see any function taking a substantial amount of time to justify the performance mismatch we were observing. In addition, async was making the flame-graph quite difficult to read because of the async scheduler and future executor appearing almost everywhere in the graph. So, we changed the profiling tool and we started using <strong><a href=https://perf.wiki.kernel.org/index.php/Main_Page>perf</a></strong> which provided, at least for us, a more clear view on the hotspots: notably on serialization and deserialization.</p><p>We improved our serializer and deserializer implementation and the synthetic benchmarks immediately improved by roughly 100%. However, that improvement didn’t reflect in the throughput tests. Nothing had changed. We were more puzzled than before.</p><h2 id=heap-or-not-to-heap-stack-is-the-problem>Heap or not to heap? Stack is the problem</h2><p>Then we started looking into memory allocations. Since the beginning of zenoh, we have been very careful to avoid heap allocations in the critical path. We used <strong><a href=https://www.valgrind.org/>Valgrind</a></strong> to double check if that was still the case and yes, it was: we didn’t observe unnecessary allocations nor suspicious high cache miss rates.</p><p>So, if it’s not the heap, it might be the stack. But how to see how deep the stack is? Especially when operating with async? Luckily for us, there is a very useful Rust compilation flag (available only in Rust nightly) to verify how big a data structure is and its cache alignment. It is sufficient to build zenoh (or any Rust code) with:</p><div class=highlight><pre tabindex=0 style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>$ <span style=color:#033>RUSTFLAGS</span><span style=color:#555>=</span>-Zprint-type-sizes cargo build --release
</span></span></code></pre></div><p>In addition to the usual Cargo output, each data structure including async futures is printed out with the corresponding size and cache alignment. An examples of the generated output for the zenoh data message Rust struct is:</p><div class=highlight><pre tabindex=0 style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>print-type-size type: <span style=color:#c30>`</span>net::protocol::proto::msg::Data<span style=color:#c30>`</span>: <span style=color:#f60>304</span> bytes, alignment: <span style=color:#f60>8</span> bytes
</span></span><span style=display:flex><span>print-type-size     field <span style=color:#c30>`</span>.key<span style=color:#c30>`</span>: <span style=color:#f60>40</span> bytes
</span></span><span style=display:flex><span>print-type-size     field <span style=color:#c30>`</span>.data_info<span style=color:#c30>`</span>: <span style=color:#f60>168</span> bytes
</span></span><span style=display:flex><span>print-type-size     field <span style=color:#c30>`</span>.payload<span style=color:#c30>`</span>: <span style=color:#f60>96</span> bytes
</span></span></code></pre></div><p>And here comes the bitter discovery. These async futures, once compiled, were taking a few tens of KBs on the stack. These futures are called every time a message needs to be sent over the network. Unsurprisingly at this stage, we realized that we were putting too much pressure on the memory due to a stack too deep and large.
Async libraries and runtime were doing their job correctly, they were putting on the stack everything that was needed in order to have a proper asynchronous environment. The problem was that we used async code too extensively in zenoh, mainly driven by its great simplicity and superb ergonomics.</p><p>So, we started a deep dive into zenoh internals and did some introspection on how to tackle the problem. We like async, it provides great flexibility and scalability properties to zenoh and we didn’t want to let it go. The final solution was to isolate the async code in specific parts of the code, especially the one interacting with the network, and to move some other parts to the standard sync library. As a result, zenoh has now a very balanced mix of sync and async code that takes the best of both worlds. This allowed us to drastically reduce the stack size of some critical async futures which immediately reflected in a massive performance boost as described below.</p><hr><h2 id=looking-at-the-results>Looking at the results</h2><p>Throughput and latency tests are provided as examples in the main zenoh distribution. So, you can check what we actually used to get our throughput and latency results and replicate it yourself!</p><p>In the following we are going to show the throughput and latency results for both peer-to-peer and routed communications. To see the communication models supported by zenoh, please refer to the <strong><a href=https://zenoh.io/docs/getting-started/key-concepts/>documentation</a></strong>.</p><p>All the tests below are run on three of our workstations equipped with an AMD Ryzen 5800x, 32 GB of RAM, connected through a 100Gb Ethernet connection, and configured according to this <strong><a href=https://easyperf.net/blog/2019/08/02/Perf-measurement-environment-on-Linux>guide</a></strong>.</p><h3 id=peer-to-peer-communication>Peer-to-peer communication</h3><p>In the peer-to-peer communication test, we consider two peers that directly communicate with each other, that is without passing through an intermediate node.</p><h4 id=throughput>Throughput</h4><p>To build and run the p2p throughput tests just follow the instruction below:</p><div class=highlight><pre tabindex=0 style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>$ git clone https://github.com/eclipse-zenoh/zenoh.git
</span></span><span style=display:flex><span>$ <span style=color:#366>cd</span> zenoh
</span></span><span style=display:flex><span>$ cargo build --release --all-targets
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#09f;font-style:italic># ---- zenoh-net test ----</span>
</span></span><span style=display:flex><span><span style=color:#09f;font-style:italic># run the zenoh-net subscriber</span>
</span></span><span style=display:flex><span>$ ./target/release/examples/zn_sub_thr
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#09f;font-style:italic># run the zenoh-net publisher with &lt;payload size&gt; (1024 below)</span>
</span></span><span style=display:flex><span>$ ./target/release/examples/zn_pub_thr <span style=color:#f60>1024</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#09f;font-style:italic># ---- zenoh test ----</span>
</span></span><span style=display:flex><span><span style=color:#09f;font-style:italic># run the zenoh subscriber</span>
</span></span><span style=display:flex><span>$ ./target/release/examples/z_sub_thr
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#09f;font-style:italic># run the zenoh publisher with &lt;payload size&gt; (1024 below)</span>
</span></span><span style=display:flex><span>$ ./target/release/examples/z_put_thr <span style=color:#f60>1024</span>
</span></span></code></pre></div><p>In this test, one workstation runs the publisher while a separate one runs the subscriber.
The figure below shows (in log scale) the number of messages per second for different payloads: from <strong>8 bytes</strong> to <strong>1 GiB</strong>.</p><p>As you can see, <strong>zenoh-net API</strong> delivers more than <strong>3.5M msg/s</strong> with a <strong>8 bytes payload</strong>.
At the same time, <strong>zenoh API</strong> delivers <strong>2M msg/s</strong>.</p><p><img src=../../img/blog-zenoh-performance-async-sync/p2p_msgs_api_log.png alt=msg-sec></p><p>The figure below shows (in log scale) the results in terms of throughput (bit/s) delivered at API level. We also report the throughput obtained with iperf on the same 100GbE connection as reference baseline: <strong>60 Gb/s</strong>.</p><p><img src=../../img/blog-zenoh-performance-async-sync/p2p_gbps_api_log.png alt=msg-sec></p><p>As it can be noticed, a <strong>100 Mb/s</strong> connection is already saturated by zenoh-net and zenoh with a payload as little as <strong>8 bytes</strong>.
A <strong>1 Gb/s</strong> connection is then saturated with a payload of <strong>32</strong> and <strong>64 bytes</strong> for zenoh-net and zenoh, respectively.
A payload of <strong>512</strong> and <strong>1024 bytes</strong> is then sufficient for zenoh-net and zenoh to saturate a <strong>10 Gb/s</strong> connection.
Finally, payloads larger than <strong>128 KB</strong> suffice to saturate a <strong>40 Gb/s</strong> connection.</p><h4 id=latency>Latency</h4><p>Throughput figures are very nice, but about latency? To run the p2p latency tests just follow the instructions below:</p><div class=highlight><pre tabindex=0 style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span><span style=color:#09f;font-style:italic># ---- zenoh-net test ----</span>
</span></span><span style=display:flex><span><span style=color:#09f;font-style:italic># run the zenoh-net pong</span>
</span></span><span style=display:flex><span>$ ./target/release/examples/zn_pong
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#09f;font-style:italic># run the zenoh-net ping</span>
</span></span><span style=display:flex><span>$ ./target/release/examples/zn_ping
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#09f;font-style:italic># ---- zenoh test ----</span>
</span></span><span style=display:flex><span><span style=color:#09f;font-style:italic># run the zenoh pong</span>
</span></span><span style=display:flex><span>$ ./target/release/examples/z_pong
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#09f;font-style:italic># run the zenoh ping</span>
</span></span><span style=display:flex><span>$ ./target/release/examples/z_ping
</span></span></code></pre></div><p>With latency is necessary to clarify one very important aspect: latency depends on the load of the system. As you can see from the figure below, as the number of messages per second increases, latency actually decreases. This is due to the fact that when messages are sent at a low rate, the processes are more likely to be descheduled by the operating system. This operation adds additional latency since the processes need to be rescheduled when messages are sent and received. This is true for both zenoh and the classical ping, which is reported as a reference baseline for latency.</p><p>The x axis of the figure below shows the number of messages that we configured to be sent in one second, from 1 to 1 million and beyond.
The inf case represents the scenario where messages are sent back-to-back as fast as possible.
In such a backlogged scenario, we can see that zenoh latency is as little as <strong>35 µsec</strong> for both zenoh-net and zenoh APIs. The payload size is <strong>64 bytes</strong>, the same as standard ICMP.</p><p><img src=../../img/blog-zenoh-performance-async-sync/p2p_latency_api.png alt=msg-sec></p><h3 id=routed-communication>Routed communication</h3><p>In the router communication test, we consider two clients that communicate with each other through an intermediate node: the zenoh router.</p><h4 id=throughput-1>Throughput</h4><p>To run the routed throughput tests just follow the instruction below:</p><div class=highlight><pre tabindex=0 style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span><span style=color:#09f;font-style:italic># ---- zenoh-net test ----</span>
</span></span><span style=display:flex><span><span style=color:#09f;font-style:italic># run the zenoh router</span>
</span></span><span style=display:flex><span>$ ./target/release/zenohd
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#09f;font-style:italic># run the zenoh-net subscriber</span>
</span></span><span style=display:flex><span>$ ./target/release/examples/zn_sub_thr -m client
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#09f;font-style:italic># run the zenoh-net publisher with &lt;payload size&gt; (1024 below)</span>
</span></span><span style=display:flex><span>$ ./target/release/examples/zn_pub_thr <span style=color:#f60>1024</span> -m client
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#09f;font-style:italic># ---- zenoh test ----</span>
</span></span><span style=display:flex><span><span style=color:#09f;font-style:italic># run the zenoh router</span>
</span></span><span style=display:flex><span>$ ./target/release/zenohd
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#09f;font-style:italic># run the zenoh subscriber</span>
</span></span><span style=display:flex><span>$ ./target/release/examples/z_sub_thr -m client
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#09f;font-style:italic># run the zenoh publisher with &lt;payload size&gt; (1024 below)</span>
</span></span><span style=display:flex><span>$ ./target/release/examples/z_put_thr <span style=color:#f60>1024</span> -m client
</span></span></code></pre></div><p>In this test, one workstation runs the publisher, one runs the router and a third one runs the subscriber.
The figure below shows (in log scale) the number of messages per second for different payloads: from <strong>8 bytes</strong> to <strong>1GiB</strong>.</p><p><img src=../../img/blog-zenoh-performance-async-sync/rtr_msgs_api_log.png alt=msg-sec></p><p>As you can see, zenoh-net API delivers <strong>3M msg/s</strong> with a <strong>8 bytes</strong> payload. At the same time, zenoh API delivers <strong>1.8M msg/s</strong>.
The figure below shows (in log scale) the same results in terms of throughput (bit/s) delivered at API level.</p><p><img src=../../img/blog-zenoh-performance-async-sync/rtr_gbps_api_log.png alt=msg-sec></p><p>As it can be noticed, a <strong>100 Mb/s</strong> connection is still saturated by zenoh-net and zenoh with a payload as little as <strong>8 bytes</strong>.
A <strong>1 Gb/s</strong> connection is then saturated with a payload of <strong>64 bytes</strong> for zenoh-net and zenoh.
A payload of <strong>1024 bytes</strong> is then sufficient for both zenoh-net and zenoh to saturate a <strong>10 Gb/s</strong> connection.
Finally, larger payloads are forwarded at <strong>20-30 Gb/s</strong>.</p><h4 id=latency-1>Latency</h4><p>To run the routed latency tests just follow the instructions below:</p><div class=highlight><pre tabindex=0 style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span><span style=color:#09f;font-style:italic># ---- zenoh-net test ----</span>
</span></span><span style=display:flex><span><span style=color:#09f;font-style:italic># run the zenoh router</span>
</span></span><span style=display:flex><span>$ ./target/release/zenohd
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#09f;font-style:italic># run the zenoh-net subscriber</span>
</span></span><span style=display:flex><span>$ ./target/release/examples/zn_pong -m client
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#09f;font-style:italic># run the zenoh-net publisher with &lt;payload size&gt; (1024 below)</span>
</span></span><span style=display:flex><span>$ ./target/release/examples/zn_ping -m client
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#09f;font-style:italic># ---- zenoh test ----</span>
</span></span><span style=display:flex><span><span style=color:#09f;font-style:italic># run the zenoh router</span>
</span></span><span style=display:flex><span>$ ./target/release/zenohd
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#09f;font-style:italic># run the zenoh subscriber</span>
</span></span><span style=display:flex><span>$ ./target/release/examples/z_pong -m client
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#09f;font-style:italic># run the zenoh publisher with &lt;payload size&gt; (1024 below)</span>
</span></span><span style=display:flex><span>$ ./target/release/examples/z_ping -m client
</span></span></code></pre></div><p>In the routed test, latency is double than the p2p test: <strong>70 µs</strong>.
This is due to the fact that an additional network hop, i.e. the router, has been introduced between the two clients.
Nevertheless, it can be noticed that the router does not add any noticeable latency to the overall communication, being the latency driven mainly by the number of hops.
The payload size is still <strong>64 bytes</strong>.</p><p><img src=../../img/blog-zenoh-performance-async-sync/rtr_latency_api.png alt=msg-sec></p><hr><h2 id=conclusions>Conclusions</h2><p>Summarizing, recent work makes zenoh capable to deliver over <strong>3.5M msg/s</strong> for small messages, over <strong>45 Gb/s</strong> for large messages, and a latency as little as <strong>35 µsec</strong>.</p><p>This has been possible thanks to the careful redesign of some core parts of zenoh that led to a more balanced mix of synchronous and asynchronous code.
Although the results are already very remarkable, rest assured, our journey towards better performance doesn’t end here!</p><p>This blog post is just a very important milestone for zenoh, not the finishing line.</p><p><a href=https://github.com/Mallets/><strong>&ndash;LC</strong></a></p><div class=ato-next><b>Next up</b>: <a href=../../blog/2021-07-05-zenoh-overhead/>Zenoh overhead: a story from our community</a></div></main></div></div><footer class="ato-footer text-muted"><div class="container-fluid p-6 p-md-5"><div class=row><div class=col-md-2><h5>Eclipse Incubation</h5><p><img src=../../img/eclipse-incubation.png style=width:100px></p><p>Eclipse zenoh &trade; is an incubating project under the Eclipse Foundation.</p></div><div class=col-md-2><h5>More Information</h5><p><a href=https://www.eclipse.org/legal target=_blank>Legal</a></p><p><a href=https://www.eclipse.org/legal/privacy.php target=_blank>Privacy policy</a></p><p><a href=https://www.eclipse.org/legal/termsofuse.php target=_blank>Terms of use</a></p><p><a href=https://www.eclipse.org/legal/copyright.php target=_blank>Copyright</a></p><p><a href=https://www.eclipse.org/security/ target=_blank>Report a security issue</a></p><p><a href=https://www.eclipse.org/legal/epl-2.0/ target=_blank>Eclipse Public License 2.0</a></p><p><a href=https://www.apache.org/licenses/LICENSE-2.0 target=_blank>Apache License 2.0</a></p><p><a href=https://www.eclipse.org/ target=_blank>Eclipse Foundation</a></p></div><div class=col-md-2><h5>Sponsored by:</h5><p><a href=https://www.eclipse.org target=_blank><img src=../../img/eclipse-foundation.svg style=width:120px></a></p><p><a href=https://zettascale.tech target=_blank><img src=../../img/zettascale-dark.svg style=width:120px></a></p></div><div class=col-md-2><h5>Follow us</h5><p><a href=https://github.com/eclipse-zenoh/zenoh><i class="fa fa-github" aria-hidden=true></i>
GitHub</a></p><p><a href=https://discord.gg/vSDSpqnbkm><i class="fa fa fa-comments-o" aria-hidden=true></i>
Discord</a></p><p><a href=https://www.youtube.com/channel/UCslbiyiqgOAPMjCrPWIfQ5Q><i class="fa fa-youtube-play" aria-hidden=true></i> Youtube</a></p><p><a href=../../docs/overview/what-is-zenoh><i class="fa fa-info-circle" aria-hidden=true></i> About</a></p></div><div class=col-md-2><p><img src=../../img/zenoh-dragon-150x163.png style=width:45px></p><p>Eclipse zenoh &trade; is free, open source and always will be.</p><p>Copyright &copy 2022 Eclipse Foundation</p><p>Built with <a href=https://gohugo.io/ target=_blank>HUGO</a></p></div></div></div></footer><script src=https://ajax.googleapis.com/ajax/libs/jquery/3.1.1/jquery.min.js integrity=sha384-3ceskX3iaEnIogmQchP8opvBy3Mi7Ce34nWjpBIwVTHfGYWQS9jwHDVRnpKKHJg7 crossorigin=anonymous></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/tether/1.3.7/js/tether.min.js integrity=sha384-XTs3FgkjiBgo8qjEjBk0tGmf3wPrWtA6coPfQDfFEY8AnYJwjalXCiosYRBIBZX8 crossorigin=anonymous></script>
<script src=../../js/bootstrap.min.js></script>
<script src=../../js/highlight.min.js></script>
<script>$(function(){$("pre code").each(function(e,t){if(t.className.indexOf("language-rust")>=0){for(var s="",n=t.textContent.split(`
`),e=0;e<n.length;e++){if(n[e].indexOf("# ")==0||n[e]=="#")continue;s+=n[e].trimRight()+`
`}t.textContent=s.replace(/\n\n\n/g,`

`).trimRight()}hljs.highlightBlock(t)})})</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-PBD6MS51QL"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-PBD6MS51QL",{anonymize_ip:!1})}</script></body></html>
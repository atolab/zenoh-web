<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Blogs on Zenoh - The Zero Overhead, Pub/Sub, Store, Query, and Compute Protocol.</title><link>/blog/</link><description>Recent content in Blogs on Zenoh - The Zero Overhead, Pub/Sub, Store, Query, and Compute Protocol.</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Wed, 30 Apr 2025 00:00:00 +0000</lastBuildDate><atom:link href="/blog/index.xml" rel="self" type="application/rss+xml"/><item><title>A Year Full of Zenoh</title><link>/blog/2020-01-01-zenohtude/</link><pubDate>Wed, 01 Jan 2020 00:00:00 +0000</pubDate><guid>/blog/2020-01-01-zenohtude/</guid><description>First of all we would like to take a moment to wish all of you a 2020 filled with joy, health, peace and success.
This year marks a very important landmark for us. After having kicked-off the Eclipse Edge Native working group, last December, we are bringing zenoh to Eclipse and are starting to work a Rust rewrite of the zenoh router. As part for the rewrite we have just about to complete a review of the zenoh protocol and will be updating the specification accordingly in the weeks to come.</description></item><item><title>Zenoh Tidings</title><link>/blog/2020-06-29-zenoh-tidings/</link><pubDate>Tue, 30 Jun 2020 00:00:00 +0000</pubDate><guid>/blog/2020-06-29-zenoh-tidings/</guid><description>In our last blog we had announced a rewrite of zenoh in Rust. The wrote the first version of zenoh in OCaml, a super-neat ML-derived functional programming language. OCaml allowed us to experiment very quickly and have good performances. Yet, one of the major feedback we were receiving from the community was that few people knew this programming language and this was limiting contributions. Beside, we had the desire to make zenoh even faster and smaller.</description></item><item><title>Zenoh Aithusa Hatched Out!</title><link>/blog/2020-10-08-aithusa/</link><pubDate>Thu, 08 Oct 2020 00:00:00 +0000</pubDate><guid>/blog/2020-10-08-aithusa/</guid><description>We have been waiting this very moment for several months. Months of patient dedication, months of hard and creative work. Months in which each and every member of the zenoh team has made his and her best to give our little dragon all it needed to succed in the complicated world of Internet Scale Protocols.
Today, at about 11.00 Paris Time Zenoh Aithusa Hatched Out!
Aithusa is the code-name for the first release of our Rust-based zenoh infrastructure, A supercharged of new features and improvements, including better performance, improved network scheduling, ROS2 integration, and DDS Plugin.</description></item><item><title>Minimizing Discovery Overhead in ROS2</title><link>/blog/2021-03-23-discovery/</link><pubDate>Tue, 23 Mar 2021 00:00:00 +0000</pubDate><guid>/blog/2021-03-23-discovery/</guid><description>The amount of discovery traffic generated by ROS2 is a problem that has received an increasing attention in the community. The discovery overhead issue becomes extremely severe when running over wireless technologies, such as WiFi, and in particular in combination with more complex robots, robot swarms and tele-operation. The ROS2 Discovery Service has been proposed as a way to alleviate the problem, not necessarily to solve it.
In the reminder of this post I&amp;rsquo;ll explain the essence of problem, remind what was tried in the past and unveils a Zenoh based solution that (1) drastically reduces DDS discovery overhead &amp;ndash; from 97% to 99,9% in tested scenarios, (2) allows for peer-to-peer communication when useful, (3) enables efficient Internet-scale routing when necessary, and (3) does not require any changes to your existing ROS2 systems.</description></item><item><title>Integrating ROS2 with Eclipse zenoh</title><link>/blog/2021-04-28-ros2-integration/</link><pubDate>Wed, 28 Apr 2021 00:00:00 +0000</pubDate><guid>/blog/2021-04-28-ros2-integration/</guid><description>In our previous blog we demonstrated how the zenoh bridge for DDS allows to (1) bridge DDS communications through zenoh, and (2) reduce by up to 99.97% the discovery traffic between the nodes.
The previous blog was focusing on demonstrating the advantages of using zenoh as the mean for ROS2-to-ROS2 communication over wireless technologies. In this blog, we’ll go one step further and will demonstrate how you can easily write native zenoh applications —meaning that has no dependencies on ROS2 — and seamlessly interact with ROS2 applications.</description></item><item><title>Zenoh Reliability, Scalability and Congestion Control</title><link>/blog/2021-06-14-zenoh-reliability/</link><pubDate>Mon, 14 Jun 2021 00:00:00 +0000</pubDate><guid>/blog/2021-06-14-zenoh-reliability/</guid><description>Providing many to many reliable communications over a wide area network is challenging. This may even be an understatement, as theoretically, even simple point to point reliable communication over asynchronous channels requires either infinite amount of memory or giving up progress… but guess what, many real systems can’t afford neither of those restrictions. Thus, trade-offs need to be made regarding reliability for the system to work, scale smoothly and have sufficiently strong guarantees.</description></item><item><title>Zenoh overhead: a story from our community</title><link>/blog/2021-07-05-zenoh-overhead/</link><pubDate>Mon, 05 Jul 2021 00:00:00 +0000</pubDate><guid>/blog/2021-07-05-zenoh-overhead/</guid><description>Zenoh&amp;rsquo;s webpage states that zenoh has a minimal wire overhead of 5 bytes. This is the result of careful considerations in the zenoh design: from using Variable Length Encoding (VLE), to efficient mapping of resource keys and automatic batching.
If you are intrigued about this and want to know more, rest assured that you are not alone. In fact, the minimal overhead aspect of zenoh attracted a lot of attention and curiosity in our community that led to some interesting discussions on zenoh&amp;rsquo;s Discord Server.</description></item><item><title>Zenoh performance: a stroll in Rust async wonderland</title><link>/blog/2021-07-13-zenoh-performance-async/</link><pubDate>Tue, 13 Jul 2021 00:00:00 +0000</pubDate><guid>/blog/2021-07-13-zenoh-performance-async/</guid><description>Since its very first public release, zenoh provided impressive and easily accessible performances (see here). But instead of resting on laurels, the zenoh team has been relentlessly working on further improving them.
As a result of this work, we are happy to announce that zenoh delivers at least twice the performances than before:
more than 3.5M msg/s with 8 bytes payload, more than 45 Gb/s with 1 Megabyte payload, a latency as little as 35 µsec in backlogged scenarios.</description></item><item><title>Indy Autonomous Challenge (IAC): Experiences from the Trenches</title><link>/blog/2021-09-28-iac-experiences-from-the-trenches/</link><pubDate>Tue, 28 Sep 2021 00:00:00 +0000</pubDate><guid>/blog/2021-09-28-iac-experiences-from-the-trenches/</guid><description>The Indy Autonomous Challenge is a competition of autonomous racecars between teams of university students. Even if fully autonomous, each car needs to communicate with its team’s base station to report telemetry, status and to receive commands, such as emergency stop. The communication infrastructure between the cars and the base stations leverages CISCO Ultra-Reliable Wireless Backhaul (CURWB). As all cars share the same infrastructure, some limitations have been imposed on teams in terms of packet rates and bandwidth usage.</description></item><item><title>Zenoh goes embedded with zenoh-pico</title><link>/blog/2021-10-04-zenoh-pico-guide/</link><pubDate>Mon, 04 Oct 2021 00:00:00 +0000</pubDate><guid>/blog/2021-10-04-zenoh-pico-guide/</guid><description>In this post, we will introduce zenoh-pico, a lightweight implementation of Zenoh APIs in C, fully compatible with its Rust counterpart.
As a result of this work, we are happy to announce that we successfully deployed and tested Zenoh in Zephyr (reel_board and nucleo-f767zi) and Arduino (ESP32) compatible boards, with initial results showcasing a quite remarkable performance within the microcontrollers landscape:
Memory footprint of only ~2.8% (nucleo-f767zi), ~9.2% (reel_board), and ~0.</description></item><item><title>ROS 2 and microcontrollers integration via Zenoh-pico</title><link>/blog/2021-11-09-ros2-zenoh-pico/</link><pubDate>Tue, 09 Nov 2021 00:00:00 +0000</pubDate><guid>/blog/2021-11-09-ros2-zenoh-pico/</guid><description>In a previous blog, we showed how you can easily write native Zenoh applications and seamlessly interact with ROS 2 applications. This was exemplified by developing a native Zenoh teleoperation application to control a ROS 2 powered robot, namely a turtlebot or its simulation counterpart turtlesim, from anywhere in the world. In this blog, we will go one step further by trying to make it cool and fun &amp;ndash; together with a bit of nostalgia.</description></item><item><title>DragonBotOne Egg Hatching with Zenoh and Zenoh-Pico</title><link>/blog/2022-02-08-dragonbot/</link><pubDate>Tue, 08 Feb 2022 00:00:00 +0000</pubDate><guid>/blog/2022-02-08-dragonbot/</guid><description>In previous blogs (1)(2), we showed how you can easily develop native Zenoh applications and seamlessly integrate them with ROS2 applications by using Zenoh bridge for DDS. In particular, this was successfully exemplified by using a TurtleBot, a well-known, low-cost, personal robot kit with open-source software and hardware.
In this blog, we go one step further to show how you can bring Zenoh down to the TurtleBot’s microcontroller and control it from a different geographic location via a Zenoh infrastructure.</description></item><item><title>Mobility, Latency and Energy saving</title><link>/blog/2022-03-30-zenoh-mobility/</link><pubDate>Wed, 30 Mar 2022 00:00:00 +0000</pubDate><guid>/blog/2022-03-30-zenoh-mobility/</guid><description>Connected cars, smart factories, swarms of robots… More and more applications need device mobility and require low latency for local device to device communications. With the increases in energy costs and its constrained availability, there is an increasing necessity to optimize data paths and to avoid unnecessary data transmissions – as just for clarity, communications takes the lion share in energy consumption when compared to computation.
Cloud centric architectures are energetically greedy and offer poor latency.</description></item><item><title>A Performance Evaluation on Rust Asynchronous Frameworks</title><link>/blog/2022-04-14-rust-async-eval/</link><pubDate>Thu, 14 Apr 2022 00:00:00 +0000</pubDate><guid>/blog/2022-04-14-rust-async-eval/</guid><description>As we previously mentioned in this blog post, Zenoh is written in Rust and leverages the async features to achieve high performance and scalability. At the present stage, we rely on the async_std framework – a decision that we took after a careful performance evaluation of the frameworks available in late 2019. This framework has proven to be quite effective, allowing Zenoh to reach more than 4M msg/s with 8 bytes payload and over 45Gb/s with 1MiB payload while keeping latency of ~30µsS.</description></item><item><title>Zenoh-Pico: Above and Beyond</title><link>/blog/2022-06-09-zenoh-pico-above-and-beyond/</link><pubDate>Thu, 09 Jun 2022 00:00:00 +0000</pubDate><guid>/blog/2022-06-09-zenoh-pico-above-and-beyond/</guid><description>In a previous blog post, we introduced Zenoh-Pico, an implementation of Zenoh for microcontrollers and embedded devices, along with a preliminary performance results and its integration on off-the-shelf robots (by bridging both legacy ROS2+DDS and Zenoh systems or by making it a full-fledged Zenoh system).
In this post, we will dive deeper on Zenoh-Pico, show, how Zenoh-Pico is capable of:
exchanging close to 2.5M msg/s for small payloads, and over 25 Gbps for larger messages, achieving end-to-end latency (i.</description></item><item><title>There is Land Besides IP: How to Cross It with Zenoh</title><link>/blog/2022-08-12-zenoh-serial/</link><pubDate>Fri, 12 Aug 2022 00:00:00 +0000</pubDate><guid>/blog/2022-08-12-zenoh-serial/</guid><description>Since the early 2000s the transition towards All-IP networks had been pushed as a natural evolutionary path. Today, IP is the dominant stack for packet-based integrated networks deployed worldwide. However, there is land beyond the ocean…in other words, there is an entire and growing non-IP universe that cannot be ignored. This universe expands at the outskirts of ordinary IP networks, where other protocols shine brighter because of more stringent requirements on overhead, energy-efficienciency, latency / real-time, and cost.</description></item><item><title>Zenoh Bahamut takes flight!</title><link>/blog/2022-09-30-zenoh-bahamut/</link><pubDate>Fri, 30 Sep 2022 00:00:00 +0000</pubDate><guid>/blog/2022-09-30-zenoh-bahamut/</guid><description>The little Zenoh dragon has vigorously grown up in the last year and now craves to take higher flight towards the highest peaks in marvellous lands.
The new 0.6.0 release of Zenoh is code-named Bahamut: the king of the good dragons. This reflects the major efforts the development team and the community have put in Zenoh to make it grow healthy, strong, wise, and resolute. Bahamut comes with a supercharged list of new features and improvements, including:</description></item><item><title>Keeping storages aligned in Zenoh</title><link>/blog/2022-11-29-zenoh-alignment/</link><pubDate>Tue, 29 Nov 2022 00:00:00 +0000</pubDate><guid>/blog/2022-11-29-zenoh-alignment/</guid><description>Zenoh Bahamut introduced a new experimental feature to support replicated storage alignment. With this feature, Zenoh ensures eventual consistency for storages that subscribe to the same key expression, even in the presence of network partitions and system faults. As promised, today we dig into some details about the storage alignment protocol. We will also give insights on how to efficiently configure a replicated storage in Zenoh.
Replicated Storages in Zenoh As we already know, Zenoh allows a user to configure storages on a given key expression.</description></item><item><title>Zenoh Charmander is coming to town</title><link>/blog/2023-01-10-zenoh-charmander/</link><pubDate>Tue, 10 Jan 2023 00:00:00 +0000</pubDate><guid>/blog/2023-01-10-zenoh-charmander/</guid><description>The new Zenoh 0.7.0 release, codename Charmander, brings to the table many features requested by the community on the Zenoh’s Discord server. Charmander introduces some long-awaited functionalities:
Mutual TLS authentication; MQTT plugin; S3 storage backend; some new freshly-landed functionalities:
Query payload; C++ binding; Connectivity status and notifications; and MISRA-C compliance for Zenoh-Pico.
Mutual TLS authentication Until now, Zenoh was only supporting server-based authentication. That is the kind of authentication you experience when surfing the web using HTTPS: your browser verifies if the server it is connecting to is legit, but the server does not authenticate your browser.</description></item><item><title>The Blue Dragon meets the Wire’s Shark</title><link>/blog/2023-01-17-zenoh-wireshark/</link><pubDate>Wed, 18 Jan 2023 00:00:00 +0000</pubDate><guid>/blog/2023-01-17-zenoh-wireshark/</guid><description>In this blog post, we will introduce Zenoh’s best friend, the Zenoh protocol dissector for Wireshark. It allows you to inspect and understand the Zenoh packets exchanged in your network. It is especially useful when you need to:
troubleshoot network problems, examine security issues, verify network applications, debug protocol implementations, and even learn about Zenoh’s protocol internals. But let’s find out more!
What is Wireshark? Wireshark is a widely-used network protocol analyzer, mostly used to sniff which packets are crossing your network.</description></item><item><title>Data Flow programming with Zenoh-Flow</title><link>/blog/2023-02-10-zenoh-flow/</link><pubDate>Fri, 10 Feb 2023 00:00:00 +0000</pubDate><guid>/blog/2023-02-10-zenoh-flow/</guid><description>Zenoh-Flow was the concluding episode of Zenoh’s webinar series &amp;ldquo;Taming the Dragon&amp;rdquo; released recently and available on ZettaScale’s Youtube channel. In case you haven’t watched the webinar (which you should definitely do!), click here! This blog provides additional insights about Zenoh-Flow: its origin, motivating use-cases, and upcoming features.
Data Flow Programming As we explained in our webinar, Zenoh-Flow is Zenoh’s native Data Flow Programming framework, offering a common abstraction applicable from the Data Center down to the microcontroller.</description></item><item><title>Comparing the Performance of Zenoh, MQTT, Kafka, and DDS</title><link>/blog/2023-03-21-zenoh-vs-mqtt-kafka-dds/</link><pubDate>Tue, 21 Mar 2023 00:00:00 +0000</pubDate><guid>/blog/2023-03-21-zenoh-vs-mqtt-kafka-dds/</guid><description>Prologue This instalment features a blog contributed by a team of researchers from the prestigious National Taiwan University (NTU). This team has been using Zenoh for some time in R2X and V2X R&amp;amp;D projects and recently did an interesting performance comparison between our blue dragon protocol, MQTT, Kafka and DDS. I&amp;rsquo;d like to thank the NTU team on behalf of the Zenoh community as this evaluation answers a couple of questions we are asked quite often.</description></item><item><title>Securing Zenoh with LetsEncrypt: A Comprehensive Guide</title><link>/blog/2023-04-04-letsencrypt/</link><pubDate>Tue, 04 Apr 2023 00:00:00 +0000</pubDate><guid>/blog/2023-04-04-letsencrypt/</guid><description>Over the last months, many people have reached out to us in our Discord server to ask if Zenoh was compatible with LetsEncrypt when using TLS as the communication transport. In other words, how to use LetsEncrypt with Zenoh.
In this blog post we&amp;rsquo;ll show it is indeed possible and we&amp;rsquo;ll go through the steps needed in order to set everything up. If you are already familiar with Transport Layer Security and LetsEncrypt, feel free to skip the explanation and dive straight into the tutorial.</description></item><item><title>Zenoh Charmander Grows Stronger</title><link>/blog/2023-06-05-charmander2/</link><pubDate>Wed, 07 Jun 2023 00:00:00 +0000</pubDate><guid>/blog/2023-06-05-charmander2/</guid><description>The new Zenoh Charmander 0.7.2-rc is out and comes with some aces up the sleeve! This patch release marks as stable the following APIs:
C++ API Query payload It introduces some new features:
C++ API is now compatible with both zenoh-c and zenoh-pico TLS supports now Let’s Encrypt and IP-based certificates Key formatters Transport protocol whitelisting It brings to life these experimental features:
Zenoh and ROS1 bridge Liveliness assertion Transparent compression And it also comes with a load of various bug fixes and improvements.</description></item><item><title>Zenoh Storage Gets a Boost: Empowering Storage with S3 Integration</title><link>/blog/2023-07-17-s3-backend/</link><pubDate>Mon, 17 Jul 2023 00:00:00 +0000</pubDate><guid>/blog/2023-07-17-s3-backend/</guid><description>As we happily announced on the blog post for the Zenoh 0.7.0-rc release (Zenoh Charmander is coming to town), we now provide enhanced backend storage capabilities with the new AmazonS3/MinIO backend implementation.
This was a requested feature that originated within our community on Discord which soon made its way into the roadmap.
The S3 backend can be installed by downloading the package from ​​https://download.eclipse.org/zenoh/zenoh-backend-s3/latest/. The source code can be found in our eclipse-zenoh repository: https://github.</description></item><item><title>Zenoh Dragonite Took Off!</title><link>/blog/2023-10-03-zenoh-dragonite/</link><pubDate>Tue, 03 Oct 2023 00:00:00 +0000</pubDate><guid>/blog/2023-10-03-zenoh-dragonite/</guid><description>We are happy to announce the release of Zenoh 0.10.0-rc Dragonite.
This version introduces new important features and improvements we have been working on the last couple of months. Specifically, this release introduces:
Improved protocol: The Best Pub/Sub/Query Protocol Gets Better New WireShark Plugin New Kotlin API Support for Ultra Low Latency ROS1 Bridge C++ API Changes &amp;amp; Documentation release The Best Pub/Sub/Query Protocol Gets Better! With this release, Zenoh gets a series of protocol improvements and extensions, such as improved support for multicast and constrained devices.</description></item><item><title>Zenoh-Flow 0.6.0-rc: Getting Started</title><link>/blog/2024-01-31-zenoh-flow-getting-started/</link><pubDate>Wed, 31 Jan 2024 00:00:00 +0000</pubDate><guid>/blog/2024-01-31-zenoh-flow-getting-started/</guid><description>At ZettaScale, we are developing a next-generation middleware called Zenoh. Zenoh gained a lot of traction with very positive feedback from diverse industries, including Robotics, Industrial Automation, Automotive and more. If you haven’t tried it yet and you think it could help you, don’t hesitate, we guarantee it’s easy and worth your time!
This blog post will focus on another exciting project we are building: Zenoh-Flow. As its name indicates, Zenoh-Flow brings together the control of data flow programming and the power of Zenoh.</description></item><item><title>Streamlining Zenoh router Monitoring with Datadog Integration</title><link>/blog/2024-04-17-datadog-zenoh-router-integration/</link><pubDate>Wed, 17 Apr 2024 00:00:00 +0000</pubDate><guid>/blog/2024-04-17-datadog-zenoh-router-integration/</guid><description>Unlocking Insights, Enhancing Efficiency Today, we&amp;rsquo;re excited to introduce a powerful integration that greatly improves the monitoring experience for Zenoh users. While Zenoh has always prioritized efficiency and performance, our Datadog integration brings a new dimension of visibility and insight to Zenoh deployments. By seamlessly integrating with Datadog, users can now monitor the state of their Zenoh routers with unprecedented ease and efficiency.
Empowering Zenoh Users The Zenoh Team understands the importance of providing users with the tools they need to manage their distributed systems effectively.</description></item><item><title>Zenoh 0.11.0 "Electrode" release is out!</title><link>/blog/2024-04-30-zenoh-electrode/</link><pubDate>Mon, 13 May 2024 00:00:00 +0000</pubDate><guid>/blog/2024-04-30-zenoh-electrode/</guid><description>During the summer of 2023, we rolled out Zenoh v0.7.0 &amp;lsquo;Charmander,&amp;rsquo; which brought significant enhancements to the Zenoh ecosystem. This was followed by the release of v0.10.0-rc &amp;lsquo;Dragonite&amp;rsquo; in autumn, and a winter update with v0.10.1-rc. This spring, we are pleased to announce Zenoh v0.11.0 “Electrode”. This release introduces several new features, some key improvements. Next will come the much-anticipated version 1.0.0, planned for June 2024🎉!
But let’s see what comes with Zenoh Electrode.</description></item><item><title>Zenoh 1.0.0 "Firesong" is ready to rock!</title><link>/blog/2024-10-21-zenoh-firesong/</link><pubDate>Tue, 01 Oct 2024 00:00:00 +0000</pubDate><guid>/blog/2024-10-21-zenoh-firesong/</guid><description>As a result of an incredible effort from the whole Zenoh team and Zenoh community, we can finally announce that Zenoh 1.0.0 Firesong is out!
This release marks an incredible milestone for Zenoh and comes with a lot of features and improvements:
API stabilization. Great attention has been given to the API, its revision and rework to provide the necessary level of stability and future extensibility. The very first alpha version of the new TypeScript API.</description></item><item><title>Zenoh 1.1.0: Firesong Keeps Rocking 🎸</title><link>/blog/2024-12-12-zenoh-firesong-1.1.0/</link><pubDate>Thu, 12 Dec 2024 00:00:00 +0000</pubDate><guid>/blog/2024-12-12-zenoh-firesong-1.1.0/</guid><description>This latest release of Zenoh 1.1.0 brings exciting new features, some of them were already introduced in the 1.0.1, 1.0.2, 1.0.3, and 1.0.4 releases. The key features are:
API Stabilization of liveliness API support. Liveliness has been part of Zenoh for quite some time but the API was still marked as unstable. We have now stabilized it. New unstable querier API for automatic queries optimization. A new unstable advanced publisher/subscriber on zenoh-ext supporting non-blocking fault tolerance end-to-end.</description></item><item><title>Introducing Raspberry Pi Pico Support in Zenoh-Pico</title><link>/blog/2025-01-08-introducing-raspberry-pi-pico-support-in-zenoh-pico/</link><pubDate>Wed, 08 Jan 2025 00:00:00 +0000</pubDate><guid>/blog/2025-01-08-introducing-raspberry-pi-pico-support-in-zenoh-pico/</guid><description>Introducing Raspberry Pi Pico Support in Zenoh-Pico We’re excited to announce that Zenoh-Pico now supports the Raspberry Pi Pico series, including the Pico W and Pico 2 W variants! Zenoh already runs seamlessly on platforms like the Raspberry Pi Zero, providing robust communication solutions for IoT. Now, with the addition of Raspberry Pi Pico support, we’ve expanded the Zenoh ecosystem to even smaller and more constrained devices.
What is Zenoh-Pico? Zenoh-Pico is the lightweight, native C implementation of the Eclipse Zenoh protocol, designed specifically for constrained devices.</description></item><item><title>Zenoh Gozuryū is Here!</title><link>/blog/2025-04-14-zenoh-gozuryu/</link><pubDate>Mon, 14 Apr 2025 00:00:00 +0000</pubDate><guid>/blog/2025-04-14-zenoh-gozuryu/</guid><description>We are thrilled to announce the release of Zenoh 1.3.3 – Gozuryū!
Named after the legendary &amp;ldquo;Five-Headed Dragon&amp;rdquo;, this release brings a powerful set of new capabilities across the entire Zenoh ecosystem, with improvements touching everything from core routing and shared memory to the language bindings and Zenoh-Pico for constrained devices.
Let’s dive into the highlights of this release.
Namespace Prefix Support: Isolate Zenoh sessions with namespace prefixes — ideal for multi-robot and multi-instance setups.</description></item><item><title>Zenoh-Pico performance improvements</title><link>/blog/2025-04-09-zenoh-pico-performance/</link><pubDate>Wed, 30 Apr 2025 00:00:00 +0000</pubDate><guid>/blog/2025-04-09-zenoh-pico-performance/</guid><description>Improving Zenoh-Pico performance Last year, after the long-awaited release of Zenoh 1.0 which included a unified C API with Zenoh-C and Zenoh-Pico, we decided to dedicate some time to measure and improve the performance and efficiency of Zenoh-Pico. These modifications were released with Zenoh 1.1 earlier this year and we present the results to you with this blog post.
What is Zenoh-Pico? Zenoh-Pico is the lightweight, native C implementation of the Eclipse Zenoh protocol, designed specifically for constrained devices.</description></item><item><title>Zenoh-Pico peer to peer unicast mode</title><link>/blog/2025-07-11-zenoh-pico-peer-to-peer-unicast/</link><pubDate>Sat, 11 Jan 2025 00:00:00 +0000</pubDate><guid>/blog/2025-07-11-zenoh-pico-peer-to-peer-unicast/</guid><description>Introduction As hinted at in our blog post about Zenoh-Pico performance improvements, we’ve now introduced a long-requested peer-to-peer unicast mode for Zenoh-Pico! Let&amp;rsquo;s dive into how it works.
What is Zenoh-Pico? Zenoh-Pico is the lightweight, native C implementation of the Eclipse Zenoh protocol, designed specifically for constrained devices. It provides a streamlined, low-resource API while supporting all abstractions from Rust Zenoh: pub, sub and query. Zenoh-Pico already supports a broad range of platforms and protocols, making it a versatile choice for embedded systems development.</description></item></channel></rss>
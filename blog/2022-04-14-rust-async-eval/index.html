<!doctype html><html lang=en><head><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.png color=#7da7d8><meta name=msapplication-TileColor content="#7da7d8"><meta name=theme-color content="#7da7d8"><meta charset=utf-8><meta name=description content="Eclipse Zenoh, unify data in motion, data at rest and computations."><meta name=keywords content="pub/sub,query,geo distributed storage,Rust,protocol,DDS,MQTT,Edge,IoT,MEC"><meta name=author content="The Zenoh Team"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta http-equiv=x-ua-compatible content="ie=edge"><link rel=stylesheet href=../../css/bootstrap-reboot.css><link rel=stylesheet href=../../css/bootstrap.css><link rel=stylesheet href=../../css/font-awesome.min.css><link rel=stylesheet href=../../css/ato.css><link rel=stylesheet href=../../css/syntax.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.css><link rel=alternate type=application/rss+xml href=../../blog/index.xml><title>A Performance Evaluation on Rust Asynchronous Frameworks · zenoh - pub/sub, geo distributed storage, query</title></head><body><header class="navbar navbar-expand navbar-dark flex-column flex-md-row ato-navbar"><a class=navbar-brand href=../../><img src=../../img/zenoh-dragon-bg.png class=align-middle alt></a><div class="collapse navbar-collapse"><ul class=navbar-nav><li class=nav-item><a class=nav-link href=../../>Home</a></li><li class=nav-item><a class=nav-link href=../../docs/overview/>Documentation</a></li><li class=nav-item><a class=nav-link href=../../community/>Community</a></li><li class=nav-item><a class=nav-link href=../../adopters/>Adopters</a></li><li class=nav-item><a class=nav-link href=../../media/>Media</a></li><li class=nav-item><a class="nav-link active" href=../../blog/2022-06-99-zenoh-pico-above-and-beyond/>Blog</a></li></ul></div><ul class="navbar-nav flex-row ml-md-auto d-none d-md-flex"><li class=nav-item><a class="nav-link p-2" href=https://github.com/eclipse-zenoh/zenoh target=_blank rel=noopener aria-label=GitHub><svg class="navbar-nav-svg" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 512 499.36" focusable="false"><title>GitHub</title><path d="M256 0C114.64.0.0 114.61.0 256c0 113.09 73.34 209 175.08 242.9 12.8 2.35 17.47-5.56 17.47-12.34.0-6.08-.22-22.18-.35-43.54-71.2 15.49-86.2-34.34-86.2-34.34-11.64-29.57-28.42-37.45-28.42-37.45-23.27-15.84 1.73-15.55 1.73-15.55 25.69 1.81 39.21 26.38 39.21 26.38 22.84 39.12 59.92 27.82 74.5 21.27 2.33-16.54 8.94-27.82 16.25-34.22-56.84-6.43-116.6-28.43-116.6-126.49.0-27.95 10-50.8 26.35-68.69-2.63-6.48-11.42-32.5 2.51-67.75.0.0 21.49-6.88 70.4 26.24a242.65 242.65.0 01128.18.0c48.87-33.13 70.33-26.24 70.33-26.24 14 35.25 5.18 61.27 2.55 67.75 16.41 17.9 26.31 40.75 26.31 68.69.0 98.35-59.85 120-116.88 126.32 9.19 7.9 17.38 23.53 17.38 47.41.0 34.22-.31 61.83-.31 70.23.0 6.85 4.61 14.81 17.6 12.31C438.72 464.97 512 369.08 512 256.02 512 114.62 397.37.0 256 0z" fill="currentcolor" fill-rule="evenodd" /></svg></a></li><li class=nav-item><a class="nav-link p-2" href=https://twitter.com/atolab_ target=_blank rel=noopener aria-label=Twitter><svg class="navbar-nav-svg" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 512 416.32" focusable="false"><title>Twitter</title><path d="M160.83 416.32c193.2.0 298.92-160.22 298.92-298.92.0-4.51.0-9-.2-13.52A214 214 0 00512 49.38a212.93 212.93.0 01-60.44 16.6 105.7 105.7.0 0046.3-58.19 209 209 0 01-66.79 25.37 105.09 105.09.0 00-181.73 71.91 116.12 116.12.0 002.66 24c-87.28-4.3-164.73-46.3-216.56-109.82A105.48 105.48.0 0068 159.6a106.27 106.27.0 01-47.53-13.11v1.43a105.28 105.28.0 0084.21 103.06 105.67 105.67.0 01-47.33 1.84 105.06 105.06.0 0098.14 72.94A210.72 210.72.0 0125 370.84a202.17 202.17.0 01-25-1.43 298.85 298.85.0 00160.83 46.92" fill="currentcolor" /></svg></a></li><li class=nav-item><a class="nav-link p-2" href=https://gitter.im/atolab/zenoh target=_blank rel=noopener aria-label=Gitter><svg class="navbar-nav-svg" xmlns="http://www.w3.org/2000/svg" focusable="false"><title>Gitter</title><path fill="currentcolor" d="M8.501 4.001H10.5V24H8.501V4.001zm6.999.0V24h-2V4.001h2zM3.5.0h2.001v15H3.5V0zm15 4.001h2V15h-2V4.001z" /></svg></a></li></ul><script async src="https://www.googletagmanager.com/gtag/js?id=UA-120904581-1"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments);}
gtag('js',new Date());gtag('config','UA-41082619-2');</script><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":""},"articleSection":"blog","name":"A Performance Evaluation on Rust Asynchronous Frameworks","headline":"A Performance Evaluation on Rust Asynchronous Frameworks","datePublished":"2022-04-14 00:00:00 \x2b0000 UTC","dateModified":"2022-04-14 00:00:00 \x2b0000 UTC","url":"\/blog\/2022-04-14-rust-async-eval\/","inLanguage":"en-US","author":"","creator":"","publisher":"","accountablePerson":"","copyrightHolder":"","copyrightYear":"14144","wordCount":"1114","keywords":[],"description":"14 April 2022 -- Paris."}</script></header><div class="container-fluid ato-blog"><div class="row flex-xl-nowrap"><div class="col-12 col-md-3 col-xl-2 ato-sidebar"><div class="ato-docs-toggle d-md-none p-0 d-flex ml-3 collapsed align-item-center"><h1 class=ato-title>A Performance Evaluation on Rust Asynchronous Frameworks</h1><button class="btn btn-link" type=button data-toggle=collapse data-target=#ato-docs-nav aria-controls=ato-docs-nav aria-expanded=false aria-label="Toggle docs navigation"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 30 30" width="30" height="30" focusable="false"><title>Menu</title><path stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-miterlimit="10" d="M4 7h22M4 15h22M4 23h22"/></svg></button></div><nav class="ato-links collapse" id=ato-docs-nav><div class="ato-toc-item active"><p class=ato-toc-link>Blog Posts</p><ul class="nav ato-sidenav"><li><a href=../../blog/2022-06-99-zenoh-pico-above-and-beyond/>Zenoh-Pico: Above and Beyond</a></li><li><a href=../../blog/2022-04-14-rust-async-eval/ class=active>A Performance Evaluation on Rust Asynchronous Frameworks</a></li><li><a href=../../blog/2022-03-30-zenoh-mobility/>Mobility, Latency and Energy saving</a></li><li><a href=../../blog/2022-02-08-dragonbot/>DragonBotOne Egg Hatching with Zenoh and Zenoh-Pico</a></li><li><a href=../../blog/2021-11-09-ros2-zenoh-pico/>ROS 2 and microcontrollers integration via Zenoh-pico</a></li><li><a href=../../blog/2021-10-04-zenoh-pico-guide/>Zenoh goes embedded with zenoh-pico</a></li><li><a href=../../blog/2021-09-28-iac-experiences-from-the-trenches/>Indy Autonomous Challenge (IAC): Experiences from the Trenches</a></li><li><a href=../../blog/2021-07-13-zenoh-performance-async/>Zenoh performance: a stroll in Rust async wonderland</a></li><li><a href=../../blog/2021-07-05-zenoh-overhead/>Zenoh overhead: a story from our community</a></li><li><a href=../../blog/2021-06-14-zenoh-reliability/>Zenoh Reliability, Scalability and Congestion Control</a></li><li><a href=../../blog/2021-04-28-ros2-integration/>Integrating ROS2 with Eclipse zenoh</a></li><li><a href=../../blog/2021-03-23-discovery/>Minimizing Discovery Overhead in ROS2</a></li><li><a href=../../blog/2020-10-08-aithusa/>Zenoh Aithusa Hatched Out!</a></li><li><a href=../../blog/2020-06-29-zenoh-tidings/>Zenoh Tidings</a></li><li><a href=../../blog/2020-01-01-zenohtude/>A Year Full of Zenoh</a></li></ul></div></nav></div><div class="d-none d-xl-block col-xl-2 ato-toc"><div class=section-nav><nav id=TableOfContents><ul><li><a href=#preparation-of-the-testing-environment>Preparation of the testing environment</a></li><li><a href=#experiment-description>Experiment Description</a></li><li><a href=#looking-at-the-results>Looking at the results</a><ul><li><a href=#localhost>Localhost</a></li><li><a href=#over-the-network>Over the network</a></li><li><a href=#adding-cpu-bounded-computing>Adding CPU bounded computing</a></li></ul></li><li><a href=#conclusions>Conclusions</a></li></ul></nav></div></div><main class="col-12 col-md-9 col-xl-8 py-md-3 pl-md-5 ato-content ato-docs"><h1 class=ato-title>A Performance Evaluation on Rust Asynchronous Frameworks</h1><p class=ato-date>14 April 2022 -- Paris.</p><p>As we previously mentioned in <a href=https://zenoh.io/blog/2021-07-13-zenoh-performance-async/>this blog post</a>, Zenoh is written in <strong>Rust</strong> and leverages the <strong>async</strong> features to achieve high performance and scalability. At the present stage, we rely on the <a href=https://async.rs/>async_std</a> framework – a decision that we took after a careful performance evaluation of the frameworks available in late 2019. This framework has proven to be quite effective, allowing Zenoh to reach more than <strong>4M</strong> msg/s with 8 bytes payload and over <strong>45Gb/s</strong> with 1MiB payload while keeping latency of <strong>~30µS</strong>.</p><p>However, <strong>async_std</strong> development seems to be stalling and the community appears to be moving towards other async frameworks, such as <strong>Tokio</strong>. As such, we decided to re-evaluate the major Rust async frameworks in order to assess the possibility to move to another framework without compromising our performances.</p><p>In this post, we will go through the evaluation of three asynchronous frameworks with respect to how they perform on asynchronous networking. Each of them will be evaluated and compared with the baseline performances provided by the equivalent synchronous primitives provided by the Rust standard library. Namely, we are targeting the following frameworks:</p><ul><li><a href=https://async.rs/>async_std</a></li><li><a href=https://tokio.rs/>Tokio</a></li><li><a href=https://github.com/smol-rs>smol</a></li></ul><h2 id=preparation-of-the-testing-environment>Preparation of the testing environment</h2><p>The first step toward reproducible results and fair evaluation is a stable and dedicated environment. In other terms, in any benchmarking effort, it is essential to reduce the number of factors that may influence the results of our performance evaluation. <a href=https://easyperf.net/blog/2019/08/02/Perf-measurement-environment-on-Linux>This guide</a> effectively summarizes how to properly setup a Linux environment and how to get consistent results. The second recommendation is to have a thorough read of <em>“<a href=https://nnethercote.github.io/perf-book/title-page.html>The Rust Performance Book</a>”</em>. If you, like us, are developing in Rust, we recommend you to go through it since we found it really insightful for what concerns performance tips and tricks along with profiling techniques in Rust. Another nice reference on how to write performant code in Rust is <a href=http://likebike.com/posts/How_To_Write_Fast_Rust_Code.html>this one</a>.</p><p>All the tests below are run on two of our workstations equipped with an AMD Ryzen 5800X @ 4.0GHz, 32 GB of RAM, running Ubuntu 20.04.3 LTS with Kernel 5.4.0-96-generic, connected through a 100Gb Ethernet connection (Mellaxon ConnectX-6 Dx).</p><h2 id=experiment-description>Experiment Description</h2><p>For such evaluation, we concentrate on Round Trip Time (RTT) by building a ping-pong application for each framework. This synthetic benchmark is essential for us as it gives a lower bound on the achievable latency as well as its behavior under “async contention”. The <strong>Round Trip Time (RTT)</strong> is the amount of time it takes for a message to be sent plus the amount of time it takes for the acknowledgment of that message being received.</p><p>The picture below illustrates the ping-pong application, and how the RTT is computed.</p><p><img src=../../img/blog-rust-async-eval/rtt.png alt=rtt></p><p>Our RTT tests are provided <a href=https://github.com/ZettaScaleLabs/rust-async-net-eval>here</a>. So, you can check what we actually used to get the RTT results and replicate it yourself!</p><h2 id=looking-at-the-results>Looking at the results</h2><p>In the following, we are presenting the RTT results for all the frameworks under two different scenarios: over localhost and over the network.</p><h3 id=localhost>Localhost</h3><p>In our first series of tests, the ping-pong application is executed on a single machine, leveraging only localhost communication.</p><h4 id=rtt>RTT</h4><p>To replicate these experiments, you can build and run the RTT test by following these instructions:</p><div class=highlight><pre style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>$ git clone https://github.com/ZettaScaleLabs/rust-async-net-eval.git
$ <span style=color:#366>cd</span> rust-async-net-eval.git
$ make

<span style=color:#09f;font-style:italic># ---- RTT in localhost ----</span>
<span style=color:#09f;font-style:italic># run all the tests in localhost</span>
$ ./run-localhost.sh -asStP

<span style=color:#09f;font-style:italic># parse the results</span>
$ python3 parse.py -d latency-logs -k rtt -o localhost-latency.pdf -l <span style=color:#f60>0</span>

</code></pre></div><p>One very important aspect to mention is that RTT depends on the load of the system. As you can see from the figure below, as the number of messages per second increases, RTT decreases. This is due to the fact that when messages are sent at a low rate, the processes are more likely to be de-scheduled by the operating system. This operation adds additional latency since the processes need to be rescheduled when messages are sent and received. This is true for both the Rust code and the classical ping, which is reported as a reference baseline for RTT.</p><p>The x-axis of the figure below shows the number of messages that we configured to be sent in one second, from a single message to 1 million and beyond. The <em>inf</em> case represents the scenario where messages are sent back-to-back as fast as possible. In such a backlogged scenario, we can see that Rust latency is as little as 5 µs for the standard library. The payload size of each message is 64 bytes, the same as standard ICMP.</p><p><img src=../../img/blog-rust-async-eval/local-0.png alt=localhost></p><h3 id=over-the-network>Over the network</h3><p>It is also interesting to see the behavior over a real physical network, as the asynchronous frameworks should take advantage of real blocking I/O operations, such as sending messages over the network. In this case, we used two workstations, one running the ping and the other one running the pong.</p><p><img src=../../img/blog-rust-async-eval/100gbe-0.png alt=net-100gbe></p><h3 id=adding-cpu-bounded-computing>Adding CPU bounded computing</h3><p>But Zenoh does not only send data, but it also has a set of CPU-bound tasks, like looking up a forwarding table, de/serializing messages, and so on. To this extent, it is interesting to validate how such frameworks perform when interleaving the I/O tasks with come computing-intensive tasks.</p><p>A Zenoh peer runs two separate tasks for each session with other Zenoh peers, so we modified the ping-pong applications to spawn a number of tasks that mimics those compute-intensive tasks.
In our tests we range from 10 to 1000 tasks, mimicking from 5 to 500 “zenoh sessions”. Figures below illustrate the different results.</p><h4 id=localhost-1>Localhost</h4><h5 id=test-for-10-tasks>Test for 10 tasks</h5><p><img src=../../img/blog-rust-async-eval/local-10.png alt=local-10></p><h5 id=test-for-1000-tasks>Test for 1000 tasks</h5><p><img src=../../img/blog-rust-async-eval/local-1000.png alt=local-1000></p><h4 id=over-a-100gbe-network>Over a 100GbE network</h4><p>In this series of tests the ping and the pong applications are running on two different machines, leveraging the 100GbE network connectivity, varying the number of computing tasks.</p><h5 id=test-for-10-tasks-1>Test for 10 tasks</h5><p><img src=../../img/blog-rust-async-eval/100gbe-10.png alt=100gbe-10></p><h5 id=test-for-100-tasks>Test for 100 tasks</h5><p><img src=../../img/blog-rust-async-eval/100gbe-100.png alt=100gbe-100></p><h5 id=test-for-1000-tasks-1>Test for 1000 tasks</h5><p><img src=../../img/blog-rust-async-eval/100gbe-1000.png alt=100gbe-1000></p><h2 id=conclusions>Conclusions</h2><p>Our evaluation shows <strong>async_std</strong> and <strong>smol</strong> are quite close to the standard library and outperform it on some workloads. On the other hand, <strong>Tokio</strong> seems to reach very soon its limit ~18µs with 100 msg/s and it shows no differences between TCP and UDP. Additionally, Tokio seems to be adversely impacted by the CPU-bound (Rust) asynchronous tasks.
Based on these results, we believe that we have no choice but remain on <strong>async-std</strong>. That said, it would be interesting to understand why <strong>Tokio</strong> exposes such behavior under contention and also to improve its raw performance to close the gap with <strong>async_std</strong>. As it stands, <strong>Tokio</strong> introduces 8µs additional latency in localhost and 10µs over the network.</p><p>Ideally, we would like to see one async framework becoming the “standard”, but to do so we can’t ignore raw performance. We look forward to engaging and working with the rest of the community to help make this happen.</p><p><a href=https://github.com/gabrik><strong>&ndash;GB</strong></a></p><div class=ato-next><b>Next up</b>: <a href=/blog/2022-03-30-zenoh-mobility/>Mobility, Latency and Energy saving</a></div></main></div></div><footer class="ato-footer text-muted"><div class="container-fluid p-6 p-md-5"><div class=row><div class=col-md-2><h5>Eclipse Incubation</h5><p><img src=../../img/eclipse-incubation.png style=width:100px></p><p>Eclipse zenoh &trade; is an incubating project under the Eclipse Foundation.</p></div><div class=col-md-2><h5>More Information</h5><p><a href=https://www.eclipse.org/legal target=_blank>Legal</a></p><p><a href=https://www.eclipse.org/legal/privacy.php target=_blank>Privacy policy</a></p><p><a href=https://www.eclipse.org/legal/termsofuse.php target=_blank>Terms of use</a></p><p><a href=https://www.eclipse.org/legal/copyright.php target=_blank>Copyright</a></p><p><a href=https://www.eclipse.org/security/ target=_blank>Report a security issue</a></p><p><a href=https://www.eclipse.org/legal/epl-2.0/ target=_blank>Eclipse Public License 2.0</a></p><p><a href=https://www.apache.org/licenses/LICENSE-2.0 target=_blank>Apache License 2.0</a></p><p><a href=https://www.eclipse.org/ target=_blank>Eclipse Foundation</a></p></div><div class=col-md-2><h5>Sponsored by:</h5><p><a href=https://www.eclipse.org target=_blank><img src=../../img/eclipse-foundation.svg style=width:120px></a></p></div><div class=col-md-2><h5>Follow us</h5><p><a href=https://github.com/eclipse-zenoh/zenoh><i class="fa fa-github" aria-hidden=true></i>GitHub</a></p><p><a href=https://gitter.im/atolab/zenoh><i class="fa fa fa-comments-o" aria-hidden=true></i>Gitter</a></p><p><a href=../../docs/overview/><i class="fa fa-info-circle" aria-hidden=true></i>About</a></p></div><div class=col-md-2><p><img src=../../img/zenoh-dragon.png style=width:45px></p><p>Eclipse zenoh &trade; is free, open source and always will be.</p><p>Copyright &copy 2021 Eclipse Foundation</p><p>Build with <a href=https://gohugo.io/ target=_blank>HUGO</a></p><p>Theme inspired from: <a href=https://tokio.rs/ target=_blank>Tokio website theme</a></p></div></div></div></footer><script src=https://ajax.googleapis.com/ajax/libs/jquery/3.1.1/jquery.min.js integrity=sha384-3ceskX3iaEnIogmQchP8opvBy3Mi7Ce34nWjpBIwVTHfGYWQS9jwHDVRnpKKHJg7 crossorigin=anonymous></script><script src=https://cdnjs.cloudflare.com/ajax/libs/tether/1.3.7/js/tether.min.js integrity=sha384-XTs3FgkjiBgo8qjEjBk0tGmf3wPrWtA6coPfQDfFEY8AnYJwjalXCiosYRBIBZX8 crossorigin=anonymous></script><script src=../../js/bootstrap.min.js></script><script src=../../js/highlight.js></script><script>$(function(){$("pre code").each(function(i,block){if(block.className.indexOf('language-rust')>=0){var new_content='';var lines=block.textContent.split('\n');for(var i=0;i<lines.length;i++){if(lines[i].indexOf('# ')==0||lines[i]=='#'){continue}
new_content+=lines[i].trimRight()+'\n';}
block.textContent=new_content.replace(/\n\n\n/g,"\n\n").trimRight();}
hljs.highlightBlock(block);});});</script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.js></script><script type=text/javascript>docsearch({apiKey:'d7b5b785798fe748621bcaa8301a2201',indexName:'zenoh',inputSelector:'#search-input',debug:false});</script><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');ga('create','UA-41082619-2','auto');ga('send','pageview');}</script></body></html>
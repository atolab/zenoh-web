---
title: "zenoh aithusa hatched out!"
date: 2020-10-08
menu: "blog"
weight: 800
description: "8 October 2020 -- Paris."
draft: false
---
We have been waiting this very moment for several months. Months of patient dedication, months of hard and creative work. Months in which each and every member of the **zenoh** team has given their best to give our little dragon all it needed to succeed in the complicated world of Internet Scale Protocols.

Today, at about 11.00 Paris time **zenoh aithusa** hatched out!

Aithusa is the code-name for the first release of our Rust-based zenoh infrastructure, supercharged with new features and improvements, including better performance, improved network scheduling, ROS2 integration, and DDS Plugin.

This blog gives you the headlines and what's next for zenoh.

## Protocol updates
zenoh aithusa has several changes at the protocol level, most notably, we have reorganised the messages to neatly separate the transport session
abstraction and the messages that are used by the protocol implementing zenoh's primitives.

This protocol-level reorganisation has the advantage of clearly decoupling the portion of zenoh-net that deals with the underlying network and the portion of the protocol that builds upon the zenoh-channel abstraction. This reorganisation makes it easier to port zenoh to disparate networks and also gives a better architecture for traffic scheduling.

Additional changes include the consolidation of data messages, now reduced to a single one, along with the addition of a generic message attachment decorator. The attachment decorator can be used by the application layer to attach arbitrary data to zenoh messages.

Finally, we have extended the representation of resources keys on the wire to allow us to effectively represent prefixes. In other terms, the previous version of zenoh could represent on the wire either a numerical resource identifier or a full resource key (meaning the string, such as "/org/eclipse/zenoh/demo/hello"). Now the protocol is able to represent resource keys made by resource identifier representing the prefix and a suffix. Thus we could represent the previous resource key as (42, "demo/hello").

This makes it possible for our runtime to play more optimisation tricks when deciding when, how and which portion of a key to map to a small integer.
What has not changed is that these integers are invisible to you and completely managed by our runtime. You can just relax and enjoy their benefits in terms of reducing the wire-overhead.

## Peers, clients and routers
zenoh aithusa supports peer-to-peer communication, as well as routed communication. Additionally, clients can leverage peers and routing nodes to communicate between each other. Likewise, group peers across separate networks can leverage routers to communicate with each other.

The routing protocol has also been updated to improve path selection while still maintaining the routing state under control.

## Performance
zenoh aithusa has major performance improvements when compared with the last release -- the OCaml version of zenoh.

As rust async-std-1.6.4 has introduced some performance regression, while we work with the async team try go back to the level of performances of async-std-1.6.2, you should try performance with 1.6.2. The SED command below does precisely that.

```
$ git clone git@github.com:eclipse-zenoh/zenoh.git
$ cd zenoh
$ find . -name "*.toml" -exec sed -i s/=1.6.4/=1.6.2/ {} \;
$ export RUSTFLAGS="-C target-cpu=native"
$ cargo build --release
$ cargo build --release --examples

# then run the throughput benchmark

# run the subscriber asking to collect 30 measurement, each measurement uses 100K messages.
$ ./target/release/examples/zn_sub_thr -s 30

# run the publisher with <payload size> (1024 below). The subscriber is discovered via UDP multicast.
$ ./target/release/examples/zn_pub_thr 1024
```

When running these tests on a testbed made by Linux workstations with an AMD Ryzen 7 3800X and 10GbE network. As you can see from the graph it reaches the 1Gbps mark for messages of 128 bytes and the 10Gbps mark for messages with a payload of just 1024 bytes.

![msg-sec](../../img/perf/2020.10.08-mgs-sec.png)

![mps](../../img/perf/2020.10.08-mbps.png)

## DDS plugin and ROS2 integration
Another goody coming with zenoh aithusa is the [DDS plugin](https://github.com/eclipse-zenoh/zenoh-plugin-dds). This allows you to  transparently route data from [Cyclone DDS](http://github.com/eclipse-cyclonedds/cyclonedds), any other DDS implementation, and ROS2. As a consequence ROS2 based robots can be teamed, monitored and managed from anywhere across the Internet!

## What's next
In the weeks to come we are releasing:

- **zenoh-pico**. A C-based [client stack for zenoh](https://github.com/eclipse-zenoh/zenoh/wiki/Zenoh--For-Microcontrollers) targeting the most constrained environments.

- **Language Bindings**. More bindings are coming up including Go-Lang and Java APIs.

- **Storages Backends**. Supporting additional storage backends for time-series and relational DBs.

- **Micro-ROS RMW**. Adding support for zenoh in MicroROS2.


Finally, do not hesitate to reach us out on the [zenoh Gitter Channel](http://gitter.im/atolab/zenoh)


[**A+**](https://github.com/kydos/)

<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Docs on Zenoh - The Zero Overhead, Pub/Sub, Store, Query, and Compute Protocol.</title><link>/docs/</link><description>Recent content in Docs on Zenoh - The Zero Overhead, Pub/Sub, Store, Query, and Compute Protocol.</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="/docs/index.xml" rel="self" type="application/rss+xml"/><item><title>What is Zenoh?</title><link>/docs/overview/what-is-zenoh/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/overview/what-is-zenoh/</guid><description>Zenoh is the Next Big Thing in Internet Computing. You may think this is a bold statement, but hopefully after this short read you&amp;rsquo;ll share the perspective.
Technically speaking, Zenoh is a pub/sub/query protocol that unifies data in motion, data at rest and computations. That said, one way of thinking about Zenoh is to imagine it as a data liberator protocol. Zenoh liberates data in several dimensions.
Cloud to the Microcontroller Communication.</description></item><item><title>Zenoh in action</title><link>/docs/overview/zenoh-in-action/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/overview/zenoh-in-action/</guid><description>Let us now look into a sample scenario of Zenoh working. Zenoh supports two paradigms of communication - publish-subscribe and queries.
Pub/Sub in Zenoh Query in Zenoh Pub/Sub in Zenoh This animation shows a basic pub/sub in action. The subscribers connected to the system receives the values send by the publishers routed efficicently through the Zenoh network. You can also observe the presence of a sleeping subscriber connected to the network.</description></item><item><title>Your first Zenoh app</title><link>/docs/getting-started/first-app/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/getting-started/first-app/</guid><description>Let us take a step-by-step approach in putting together your first Zenoh application in Python. As the first step, let us see how we get some data from a temperature sensor in our kitchen. Then we see how we can route this data to store and perform some analytics.
Before cranking some code, let&amp;rsquo;s define some terminology.
Zenoh deals with keys/values where each key is a path and is associated to a value.</description></item><item><title>Installation</title><link>/docs/getting-started/installation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/getting-started/installation/</guid><description>To start playing with Zenoh we need the Zenoh router and/or the Zenoh client library.
Installing client library To develop your application Zenoh, you need to install a Zenoh client library. Depending on your programming language, pick one of the following API and refer to the installation and usage instructions in here:
Rust API Python API C API Pico API: A port of Zenoh in C, targeted at low-power devices.</description></item><item><title>Deployment</title><link>/docs/getting-started/deployment/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/getting-started/deployment/</guid><description>Peer to peer By default Zenoh applications are configured to communicate peer to peer (peer mode). All applications in the local network directly communicate with each other.
Configuration
{ mode: peer, } Scouting Zenoh applications in peer mode run both multicast and gossip scouting to discover other applications or Zenoh routers and connect them.
Multicast scouting
Zenoh applications in peer mode join multicast group 224.0.0.224 on UDP port 7447 and send scout messages on this address to discover local applications and routers.</description></item><item><title>For a quick test using Docker</title><link>/docs/getting-started/quick-test/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/getting-started/quick-test/</guid><description>This page describe how to perform a quick test of Zenoh, using a Docker image.
Run Zenoh router in a Docker container The Zenoh router is also available in a Docker image. You can deploy a single instance on your local host just running:
docker run --init -p 7447:7447/tcp -p 8000:8000/tcp eclipse/zenoh The ports used by Zenoh are the following:
7447/tcp : the Zenoh protocol via TCP 8000/tcp : the Zenoh REST API ⚠️ WARNING ⚠️: Docker doesn&amp;rsquo;t support UDP multicast between a container and its host (see cases moby/moby#23659, moby/libnetwork#2397 or moby/libnetwork#552).</description></item><item><title>Troubleshooting</title><link>/docs/getting-started/troubleshooting/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/getting-started/troubleshooting/</guid><description>Activate logging Activating the Zenoh logging can provide useful information for any troubleshooting. The Zenoh router (zenohd) and all the Zenoh APIs (except zenoh-pico) are developed with a Rust code base. Logging is controlled via the RUST_LOG environment variable that can typically be defined with the desired logging level amongst:
error - this is the default level if RUST_LOG is not defined warn info debug trace off - to disable all logging More advanced logging directives can be defined via the RUST_LOG.</description></item><item><title>Abstractions</title><link>/docs/manual/abstractions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/manual/abstractions/</guid><description>Zenoh is a distributed service to define, manage and operate on key/value spaces.
The main abstractions at the core of Zenoh are the following:
Key Zenoh operates on key/value pairs. The most important thing to know about Zenoh keys is that / is the hierarchical separator, just like in unix filesystems. While you could set up your own hierarchy using other separators, your Zenoh exchanges would benefit from better performance using /, as it will let Zenoh do clever optimisations (users have informed us in the past that switching from .</description></item><item><title>Configuration</title><link>/docs/manual/configuration/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/manual/configuration/</guid><description>From version 0.6 of Zenoh, configuration has changed in major ways. This page will take you through the new behaviour of configuration, whether you&amp;rsquo;re using Zenoh as a library, or as an executable through zenohd.
Configuring zenohd There are 3 ways to configure zenohd, which may be used in any combination:
using a configuration file, through the command line arguments, and by putting values on the configuration through the adminspace. Configuration files zenohd has supported configuration files for a long time now, but with version 0.</description></item><item><title>Zenoh plugins</title><link>/docs/manual/plugins/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/manual/plugins/</guid><description>The Zenoh router (zenohd executable) supports the loading of plugins at start-up, or at runtime if write permission is configured on its admin space.
A Zenoh plugin is a library that can be loaded by the Zenoh router at start-up. It shares a runtime with it, allowing the plugin to use the regular Zenoh rust APIs with the same peer ID.
Zenoh already provides the following plugins in its default repository:</description></item><item><title>REST plugin</title><link>/docs/manual/plugin-http/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/manual/plugin-http/</guid><description>The REST plugin provides access to the Zenoh REST API by enabling an HTTP server on the Zenoh node where it is running.
Library name: zplugin_rest
There are two main ways to start this plugin:
Through startup arguments: zenohd&amp;rsquo;s --rest-http-port=[PORT | IP:PORT | none] argument allows you to choose which port will be listened to by the HTTP server. Note that the default value for this argument is 8000, meaning that unless you specify none explicitly, zenohd will use this plugin by default.</description></item><item><title>Storage manager plugin</title><link>/docs/manual/plugin-storage-manager/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/manual/plugin-storage-manager/</guid><description>The storage_manager plugin provides zenohd with the ability to store values associated with a set of keys, allowing other nodes to query the most recent values associated with these keys.
Library name: zplugin_storage_manager
Backends and Volumes Since there exist many ways for a Zenoh node to store values it may need to serve later, the storage manager plugin relies on dynamically loaded &amp;ldquo;backends&amp;rdquo; to provide this functionality. Typically, a backend will leverage some third-party technology, such as databases, to handle storage.</description></item><item><title>TLS authentication</title><link>/docs/manual/tls/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/manual/tls/</guid><description>Zenoh supports TLS as a transport protocol. As of today, the only supported TLS authentication mode is server-authentication: clients validate the server TLS certificate but not the other way around. That is, the same way of operating on the web where the web browsers validate the identity of the server via means of the TLS certificate. The configuration of TLS certificates is done via a configuration file.
TLS certificates creation In order to use TLS as a transport protocol, we need first to create the TLS certificates.</description></item><item><title>QUIC transport</title><link>/docs/manual/quic/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/manual/quic/</guid><description>Zenoh supports QUIC as a transport protocol.
As you may already know, QUIC is a UDP-based, stream-multiplexing, encrypted transport protocol. It natively embeds TLS for encryption, authentication and confidentiality.
As of today, the only supported TLS authentication mode in Zenoh is server-authentication: clients validate the server TLS certificate but not the other way around. That is, the same way of operating on the web where the web browsers validate the identity of the server via means of the TLS certificate.</description></item><item><title>User-Password authentication</title><link>/docs/manual/user-password/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/manual/user-password/</guid><description>Zenoh supports basic user-password authentication. Clients and peers can use user and password for authentication against a router or a peer. Similarly, peers and routers can use user and password for authentication among themselves. The configuration of credentials is done via a configuration file.
Client configuration The required configuration fields for a client would hence be:
{ /// The node&amp;#39;s mode (router, peer or client) mode: &amp;#34;client&amp;#34;, transport: { auth: { /// The configuration of authentication.</description></item><item><title>Rust API</title><link>/docs/apis/rust/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/apis/rust/</guid><description> The Rust API documentation is available on Read the Docs.</description></item><item><title>C API</title><link>/docs/apis/c/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/apis/c/</guid><description> The C API documentation is available on Read the Docs.</description></item><item><title>Python API</title><link>/docs/apis/python/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/apis/python/</guid><description> The Python API documentation is available on Read the Docs.</description></item><item><title>REST API</title><link>/docs/apis/rest/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/apis/rest/</guid><description>Zenoh also offers a REST API via the zenoh-rest plugin. When starting Zenoh with default options, this REST plugin is automatically started on port 8000 and ready to answer HTTP requests.
The full Zenoh key/value space is accessible via this REST API, including the Admin Space under the '@'prefix.
GET Binds to the get(selector) operation on Zenoh.
URL: http://host:8000/&amp;lt;selector&amp;gt; body: none headers: none The results are returned as a JSON array of objects containing &amp;quot;key&amp;quot;, &amp;quot;value&amp;quot;and &amp;quot;time&amp;quot;.</description></item><item><title>Migrating from Zenoh v0.5.x to Zenoh v0.6.x</title><link>/docs/migration/migrationguide-v0.5.x-v0.6.x/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/migration/migrationguide-v0.5.x-v0.6.x/</guid><description>Key expressions Some key expressions are now considered invalid:
Heading slashes are forbidden. Example: &amp;quot;/key/expression&amp;quot;. Trailing slashes are forbidden. Example: &amp;quot;key/expression/&amp;quot;. Empty chunks are forbidden. Example: &amp;quot;key//expression&amp;quot;. An error will be returned when trying to use such invalid key expressions.
APIs In zenoh version 0.6.0, zenoh and zenoh-net APIs have been merged into a single API.
Configuration In v0.5.x the Zenoh configuration was a list of key/value pairs. In v0.6.x the has a structured format which can be expressed in JSON, JSON5 or YAML.</description></item><item><title>Migrating from Zenoh v0.5.x Rust API to Zenoh v0.6.x Rust API</title><link>/docs/migration/migrationguide-rust-v0.5.x-v0.6.x/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/migration/migrationguide-rust-v0.5.x-v0.6.x/</guid><description>In zenoh version 0.6.0, zenoh and zenoh-net APIs have been merged into a single API.
General considerations about the new Rust v0.6.x zenoh API Resolvables Most of the operations of the new API return builder structs that implement the Resolvable, SyncResolve and AsyncResolve traits. A res function needs to be called on those builders to obtain the final result of the operation. When using Rust sync, the SyncResolve trait needs to be used and the res function directly returns the final result.</description></item><item><title>Migrating from Zenoh-C v0.5.x zenoh-net API to Zenoh-C v0.6.x zenoh API</title><link>/docs/migration/migrationguide-c-v0.5.x-v0.6.x/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/migration/migrationguide-c-v0.5.x-v0.6.x/</guid><description>Opening a session All types and operations from the zn_* primitives have been updated and migrated to the z_* primitives.
zenoh v0.5.x
zn_properties_t *config = zn_config_default(); zn_session_t *s = zn_open(config); if (s == NULL) { printf(&amp;#34;Unable to open session!\n&amp;#34;); exit(-1); } zenoh v0.6.x
z_owned_config_t config = z_config_default(); z_owned_session_t s = z_open(z_move(config)); if (!z_check(s)) { printf(&amp;#34;Unable to open session!\n&amp;#34;); exit(-1); } Subscribing For this release, Zenoh-C only supports subscribers with callbacks. It is possible to access samples through a callback by calling the callback function passed as argument on declare_subscriber function.</description></item><item><title>Migrating from Zenoh v0.5.x Python API to Zenoh v0.6.x Python API</title><link>/docs/migration/migrationguide-python-v0.5.x-v0.6.x/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/migration/migrationguide-python-v0.5.x-v0.6.x/</guid><description>Explorability In previous releases, the Python bindings were entirely defined in Rust, making it very hard for Pythoners to explore it.
With 0.6, the bindings have evolved: a &amp;ldquo;private&amp;rdquo; layer is exposed by Rust, and wrapped in Python, with 2 main advantages:
IDEs can now find available symbols, signatures and documentation more easily. Any dynamic type handling is done in Python, letting you investigate what happens depending on the types of values you pass more easily.</description></item><item><title>Migrating from Zenoh-Pico v0.5.x to Zenoh-Pico v0.6.x</title><link>/docs/migration/migrationguide-pico-v0.5.x-v0.6.x/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/migration/migrationguide-pico-v0.5.x-v0.6.x/</guid><description>General considerations about the new Zenoh-Pico v0.6.x API Ownership model The new Zenoh-Pico API, similarly to the Zenoh-C API, introduced a more explicit ownership model to the user. Such model targets a better memory management where e.g. memory leaks can be easily identified and double free can be avoided. The user will have a clear understanding on what is owned by his side of the code, and what has been loaned or moved to the API.</description></item><item><title>Migrating from Zenoh-C to Zenoh-Pico (and vice-versa)</title><link>/docs/migration/migrationguide-zenohc-zenohpico/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>/docs/migration/migrationguide-zenohc-zenohpico/</guid><description>Both Zenoh-C and Zenoh-Pico APIs offer a C client API for the zenoh protocol, thus this release took an extra step to make Zenoh-C code to be compatible with Zenoh-Pico code (and vice-versa). Such approach aids users to easily migrate its Zenoh-based code to microcontrollers and embedded systems.
Nevertheless, in order to keep your code optimal some minor changes might be required while moving from Zenoh-C to Zenoh-Pico:
zc_* refers to Zenoh-C API only, while zp_* refers to Zenoh-Pico API only.</description></item></channel></rss>
<!doctype html><html lang=en><head><link rel=apple-touch-icon sizes=180x180 href=../../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../../favicon-16x16.png><link rel=manifest href=../../../site.webmanifest><link rel=mask-icon href=../../../safari-pinned-tab.png><meta name=msapplication-TileImage content="/safari-pinned-tab.png"><meta name=msapplication-TileColor content="#7da7d8"><meta name=theme-color content="#7da7d8"><meta charset=utf-8><meta name=description content="Eclipse Zenoh, unify data in motion, data at rest and computations."><meta name=keywords content="pub/sub,query,geo distributed storage,Rust,protocol,DDS,MQTT,Edge,IoT,MEC"><meta name=author content="The Zenoh Team"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta http-equiv=x-ua-compatible content="ie=edge"><link rel=stylesheet href=../../../css/bootstrap-reboot.css><link rel=stylesheet href=../../../css/bootstrap.css><link rel=stylesheet href=../../../css/font-awesome.min.css><link rel=stylesheet href=../../../css/ato.css><link rel=stylesheet href=../../../css/syntax.css><link rel=alternate type=application/rss+xml href=../../../blog/index.xml><title>C / Pico · Zenoh - pub/sub, geo distributed storage, query</title></head><body><header class="navbar-expand navbar-dark d-flex flex-column flex-md-row align-items-md-center ato-navbar"><div class="d-flex flex-row justify-content-between pl-2 pr-2"><a class=navbar-brand href=../../../><img src=../../../img/zenoh-dragon-bg-150x163.png class=align-middle alt></a>
<button class="btn btn-link d-md-none p-0" type=button data-toggle=collapse data-target=#ato-nav aria-controls=ato-nav aria-expanded=false aria-label="Toggle navigation"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 30 30" width="30" height="30" focusable="false"><title>Menu</title><path stroke="#fff" stroke-width="2" stroke-linecap="round" stroke-miterlimit="10" d="M4 7h22M4 15h22M4 23h22"/></svg></button></div><div class="ato-links collapse pl-4 pl-md-0" id=ato-nav><ul class="navbar-nav flex-column flex-md-row"><li class=nav-item><a class=nav-link href=../../../>Home</a></li><li class=nav-item><a class="nav-link active" href=../../../docs/getting-started/first-app/>Documentation</a></li><li class=nav-item><a class=nav-link href=../../../usecases/>Use Cases</a></li><li class=nav-item><a class=nav-link href=../../../community/>Community</a></li><li class=nav-item><a class=nav-link href=../../../adopters/>Adopters</a></li><li class=nav-item><a class=nav-link href=../../../media/>Media</a></li><li class=nav-item><a class=nav-link href=../../../blog/2024-04-30-zenoh-electrode/>Blog</a></li></ul></div><ul class="navbar-nav flex-row ml-md-auto d-none d-md-flex"><li class=nav-item><a class="nav-link p-2" href=https://github.com/eclipse-zenoh/zenoh target=_blank rel=noopener aria-label=GitHub><svg class="navbar-nav-svg" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 512 499.36" focusable="false"><title>GitHub</title><path d="M256 0C114.64.0.0 114.61.0 256c0 113.09 73.34 209 175.08 242.9 12.8 2.35 17.47-5.56 17.47-12.34.0-6.08-.22-22.18-.35-43.54-71.2 15.49-86.2-34.34-86.2-34.34-11.64-29.57-28.42-37.45-28.42-37.45-23.27-15.84 1.73-15.55 1.73-15.55 25.69 1.81 39.21 26.38 39.21 26.38 22.84 39.12 59.92 27.82 74.5 21.27 2.33-16.54 8.94-27.82 16.25-34.22-56.84-6.43-116.6-28.43-116.6-126.49.0-27.95 10-50.8 26.35-68.69-2.63-6.48-11.42-32.5 2.51-67.75.0.0 21.49-6.88 70.4 26.24a242.65 242.65.0 01128.18.0c48.87-33.13 70.33-26.24 70.33-26.24 14 35.25 5.18 61.27 2.55 67.75 16.41 17.9 26.31 40.75 26.31 68.69.0 98.35-59.85 120-116.88 126.32 9.19 7.9 17.38 23.53 17.38 47.41.0 34.22-.31 61.83-.31 70.23.0 6.85 4.61 14.81 17.6 12.31C438.72 464.97 512 369.08 512 256.02 512 114.62 397.37.0 256 0z" fill="currentcolor" fill-rule="evenodd"/></svg></a></li><li class=nav-item><a class="nav-link p-2" href=https://twitter.com/zettascaletech target=_blank rel=noopener aria-label=Twitter><svg class="navbar-nav-svg" xmlns="http://www.w3.org/2000/svg" viewbox="0 0 512 416.32" focusable="false"><title>Twitter</title><path d="M160.83 416.32c193.2.0 298.92-160.22 298.92-298.92.0-4.51.0-9-.2-13.52A214 214 0 00512 49.38a212.93 212.93.0 01-60.44 16.6 105.7 105.7.0 0046.3-58.19 209 209 0 01-66.79 25.37 105.09 105.09.0 00-181.73 71.91 116.12 116.12.0 002.66 24c-87.28-4.3-164.73-46.3-216.56-109.82A105.48 105.48.0 0068 159.6a106.27 106.27.0 01-47.53-13.11v1.43a105.28 105.28.0 0084.21 103.06 105.67 105.67.0 01-47.33 1.84 105.06 105.06.0 0098.14 72.94A210.72 210.72.0 0125 370.84a202.17 202.17.0 01-25-1.43 298.85 298.85.0 00160.83 46.92" fill="currentcolor"/></svg></a></li><li class=nav-item><a class="nav-link p-2" href=https://discord.gg/2GJ958VuHs target=_blank rel=noopener aria-label=Discord><svg class="navbar-nav-svg" xmlns="http://www.w3.org/2000/svg" focusable="false"><title>Discord</title><path fill="currentcolor" d="M13.545 2.907a13.227 13.227.0 00-3.257-1.011.05.05.0 00-.052.025c-.141.25-.297.577-.406.833a12.19 12.19.0 00-3.658.0 8.258 8.258.0 00-.412-.833.051.051.0 00-.052-.025c-1.125.194-2.22.534-3.257 1.011a.041.041.0 00-.021.018C.356 6.024-.213 9.047.066 12.032c.001.014.01.028.021.037a13.276 13.276.0 003.995 2.02.05.05.0 00.056-.019c.308-.42.582-.863.818-1.329a.05.05.0 00-.01-.059.051.051.0 00-.018-.011 8.875 8.875.0 01-1.248-.595.05.05.0 01-.02-.066.051.051.0 01.015-.019c.084-.063.168-.129.248-.195a.05.05.0 01.051-.007c2.619 1.196 5.454 1.196 8.041.0a.052.052.0 01.053.007c.08.066.164.132.248.195a.051.051.0 01-.004.085 8.254 8.254.0 01-1.249.594.05.05.0 00-.03.03.052.052.0 00.003.041c.24.465.515.909.817 1.329a.05.05.0 00.056.019 13.235 13.235.0 004.001-2.02.049.049.0 00.021-.037c.334-3.451-.559-6.449-2.366-9.106a.034.034.0 00-.02-.019zm-8.198 7.307c-.789.0-1.438-.724-1.438-1.612.0-.889.637-1.613 1.438-1.613.807.0 1.45.73 1.438 1.613.0.888-.637 1.612-1.438 1.612zm5.316.0c-.788.0-1.438-.724-1.438-1.612.0-.889.637-1.613 1.438-1.613.807.0 1.451.73 1.438 1.613.0.888-.631 1.612-1.438 1.612z"/></svg></a></li><li class=nav-item><a class="nav-link p-2" href=https://www.youtube.com/channel/UCslbiyiqgOAPMjCrPWIfQ5Q target=_blank rel=noopener aria-label=Youtube><svg class="navbar-nav-svg" xmlns="http://www.w3.org/2000/svg" focusable="false"><title>Youtube</title><path fill="currentcolor" d="M8.051 1.999h.089c.822.003 4.987.033 6.11.335a2.01 2.01.0 011.415 1.42c.101.38.172.883.22 1.402l.01.104.022.26.008.104c.065.914.073 1.77.074 1.957v.075c-.001.194-.01 1.108-.082 2.06l-.008.105-.009.104c-.05.572-.124 1.14-.235 1.558a2.007 2.007.0 01-1.415 1.42c-1.16.312-5.569.334-6.18.335h-.142c-.309.0-1.587-.006-2.927-.052l-.17-.006-.087-.004-.171-.007-.171-.007c-1.11-.049-2.167-.128-2.654-.26a2.007 2.007.0 01-1.415-1.419c-.111-.417-.185-.986-.235-1.558L.09 9.82.082 9.716A31.4 31.4.0 010 7.68v-.123c.002-.215.01-.958.064-1.778l.007-.103.003-.052.008-.104.022-.26.01-.104c.048-.519.119-1.023.22-1.402a2.007 2.007.0 011.415-1.42c.487-.13 1.544-.21 2.654-.26l.17-.007.172-.006.086-.003.171-.007A99.788 99.788.0 017.858 2h.193zM6.4 5.209v4.818l4.157-2.408L6.4 5.209z"/></svg></a></li></ul><script async src="https://www.googletagmanager.com/gtag/js?id=G-PBD6MS51QL"></script>
<script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-PBD6MS51QL")</script><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":""},"articleSection":"docs","name":"C \/ Pico","headline":"C \/ Pico","datePublished":"0001-01-01 00:00:00 \u002b0000 UTC","dateModified":"0001-01-01 00:00:00 \u002b0000 UTC","url":"\/docs\/migration_1.0\/c_pico\/","inLanguage":"en-US","author":"","creator":"","publisher":"","accountablePerson":"","copyrightHolder":"","copyrightYear":"1011","wordCount":"2996","keywords":[],"description":"General API changes We have reworked the type naming to clarify how types should be interacted with.\nOwned types Owned types are allocated by the user and it is their responsibility to drop them using z_drop (or z_close for sessions).\nPreviously, we were returning Zenoh structures by value. In Zenoh 1.0.0, a reference to memory must be provided. This allows initializing user allocated structures and frees return value for error codes."}</script></header><div class="container-fluid ato-docs"><div class="row flex-xl-nowrap"><div class="col-12 col-md-3 col-xl-2 ato-sidebar"><div class="ato-search d-flex justify-content-end"><button class="btn btn-link ato-search-docs-toggle d-md-none p-0 ml-3" type=button data-toggle=collapse data-target=#ato-docs-nav aria-controls=ato-docs-nav aria-expanded=false aria-label="Toggle docs navigation"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 30 30" width="30" height="30" focusable="false"><title>Menu</title><path stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-miterlimit="10" d="M4 7h22M4 15h22M4 23h22"/></svg></button></div><nav class="ato-links collapse" id=ato-docs-nav><div class=ato-toc-item><a class=ato-toc-link href=../../../docs/overview/what-is-zenoh/>Overview</a><ul class="nav ato-sidenav"><li><a href=../../../docs/overview/what-is-zenoh/>What is Zenoh?</a></li><li><a href=../../../docs/overview/zenoh-in-action/>Zenoh in action</a></li></ul></div><div class=ato-toc-item><a class=ato-toc-link href=../../../docs/getting-started/first-app/>Getting started</a><ul class="nav ato-sidenav"><li><a href=../../../docs/getting-started/first-app/>Your first Zenoh app</a></li><li><a href=../../../docs/getting-started/installation/>Installation</a></li><li><a href=../../../docs/getting-started/deployment/>Deployment</a></li><li><a href=../../../docs/getting-started/quick-test/>For a quick test using Docker</a></li><li><a href=../../../docs/getting-started/troubleshooting/>Troubleshooting</a></li></ul></div><div class=ato-toc-item><a class=ato-toc-link href=../../../docs/manual/abstractions/>Reference manual</a><ul class="nav ato-sidenav"><li><a href=../../../docs/manual/abstractions/>Abstractions</a></li><li><a href=../../../docs/manual/configuration/>Configuration</a></li><li><a href=../../../docs/manual/plugins/>Zenoh plugins</a></li><li><a href=../../../docs/manual/plugin-http/>REST plugin</a></li><li><a href=../../../docs/manual/plugin-storage-manager/>Storage manager plugin</a></li><li><a href=../../../docs/manual/tls/>TLS authentication</a></li><li><a href=../../../docs/manual/quic/>QUIC transport</a></li><li><a href=../../../docs/manual/user-password/>User-Password authentication</a></li><li><a href=../../../docs/manual/access-control/>Access Control</a></li></ul></div><div class=ato-toc-item><a class=ato-toc-link href=../../../docs/apis/rust/>API</a><ul class="nav ato-sidenav"><li><a href=../../../docs/apis/rust/>Rust API</a></li><li><a href=../../../docs/apis/c/>C API</a></li><li><a href=../../../docs/apis/cpp/>C++ API</a></li><li><a href=../../../docs/apis/python/>Python API</a></li><li><a href=../../../docs/apis/rest/>REST API</a></li><li><a href=../../../docs/apis/kotlin/>Kotlin API</a></li></ul></div><div class=ato-toc-item><a class=ato-toc-link href=../../../docs/migration_0.5_to_0.6/migrationguide-v0.5.x-v0.6.x/>Migration guides v0.5.x → v0.6.x</a><ul class="nav ato-sidenav"><li><a href=../../../docs/migration_0.5_to_0.6/migrationguide-v0.5.x-v0.6.x/>Migrating from Zenoh v0.5.x to Zenoh v0.6.x</a></li><li><a href=../../../docs/migration_0.5_to_0.6/migrationguide-rust-v0.5.x-v0.6.x/>Migrating from Zenoh v0.5.x Rust API to Zenoh v0.6.x Rust API</a></li><li><a href=../../../docs/migration_0.5_to_0.6/migrationguide-c-v0.5.x-v0.6.x/>Migrating from Zenoh-C v0.5.x zenoh-net API to Zenoh-C v0.6.x zenoh API</a></li><li><a href=../../../docs/migration_0.5_to_0.6/migrationguide-python-v0.5.x-v0.6.x/>Migrating from Zenoh v0.5.x Python API to Zenoh v0.6.x Python API</a></li><li><a href=../../../docs/migration_0.5_to_0.6/migrationguide-pico-v0.5.x-v0.6.x/>Migrating from Zenoh-Pico v0.5.x to Zenoh-Pico v0.6.x</a></li><li><a href=../../../docs/migration_0.5_to_0.6/migrationguide-zenohc-zenohpico/>Migrating from Zenoh-C to Zenoh-Pico (and vice-versa)</a></li></ul></div><div class="ato-toc-item active"><a class=ato-toc-link href=../../../docs/migration_1.0/concepts/>Migration guides v0.11 → v1.0</a><ul class="nav ato-sidenav"><li><a href=../../../docs/migration_1.0/concepts/>Concepts</a></li><li><a href=../../../docs/migration_1.0/rust/>Rust</a></li><li><a href=../../../docs/migration_1.0/c++/>C++</a></li><li><a href=../../../docs/migration_1.0/c_pico/ class=active>C / Pico</a></li><li><a href=../../../docs/migration_1.0/python/>Python</a></li><li><a href=../../../docs/migration_1.0/java/>Java</a></li><li><a href=../../../docs/migration_1.0/kotlin/>Kotlin</a></li></ul></div></nav></div><div class="d-none d-xl-block col-xl-2 ato-toc"><div class=section-nav><nav id=TableOfContents><ul><li><a href=#general-api-changes>General API changes</a><ul><li><a href=#owned-types>Owned types</a></li><li><a href=#moved-types>Moved types</a></li><li><a href=#loaned-types>Loaned types</a></li><li><a href=#view-types>View types</a></li></ul></li><li><a href=#payload-and-serialization>Payload and Serialization</a></li><li><a href=#channel-handlers-and-callbacks>Channel Handlers and Callbacks</a></li><li><a href=#attachment>Attachment</a></li><li><a href=#encoding>Encoding</a></li><li><a href=#timestamps>Timestamps</a></li><li><a href=#error-handling>Error Handling</a></li><li><a href=#keyexpr--string-conversion>KeyExpr / String Conversion</a></li><li><a href=#accessor-pattern>Accessor Pattern</a></li><li><a href=#usage-of-z_bytes_clone>Usage of <code>z_bytes_clone</code></a></li><li><a href=#zenoh-c-specific>Zenoh-C Specific</a><ul><li><a href=#shared-memory>Shared Memory</a></li></ul></li></ul></nav></div></div><main class="col-12 col-md-9 col-xl-8 py-md-3 pl-md-5 ato-content ato-docs"><h1 class=ato-title>C / Pico</h1><div class=github-edit><a class="fa fa-github" href=https://github.com/atolab/zenoh-web/tree/master/content/docs/migration_1.0/C_Pico.md>Edit on GitHub</a></div><h2 id=general-api-changes>General API changes</h2><p>We have reworked the type naming to clarify how types should be interacted with.</p><h3 id=owned-types>Owned types</h3><p>Owned types are allocated by the user and it is their responsibility to drop them using <code>z_drop</code> (or <code>z_close</code> for sessions).</p><p>Previously, we were returning Zenoh structures by value. In Zenoh 1.0.0, a reference to memory must be provided. This allows initializing user allocated structures and frees return value for error codes.</p><p>Here is a quick example of this change:</p><ul><li>Zenoh 0.11.x</li></ul><div class=highlight><pre tabindex=0 style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>z_owned_session_t session <span style=color:#555>=</span> z_open(z_move(config));
</span></span><span style=display:flex><span><span style=color:#069;font-weight:700>if</span> (<span style=color:#555>!</span>z_check(session)) {
</span></span><span style=display:flex><span>    <span style=color:#069;font-weight:700>return</span> <span style=color:#555>-</span><span style=color:#f60>1</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>z_close(z_move(session));
</span></span></code></pre></div><ul><li>Zenoh 1.0.0</li></ul><div class=highlight><pre tabindex=0 style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>z_owned_session_t session;
</span></span><span style=display:flex><span><span style=color:#069;font-weight:700>if</span> (z_open(<span style=color:#555>&amp;</span>session, z_move(config), <span style=color:#555>&amp;</span>opts) <span style=color:#555>&lt;</span> <span style=color:#f60>0</span>) {
</span></span><span style=display:flex><span>  <span style=color:#069;font-weight:700>return</span> <span style=color:#555>-</span><span style=color:#f60>1</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>z_close(z_move(session))
</span></span></code></pre></div><p>The owned objects have a “null” state.</p><ul><li>If the constructor function (e.g. <code>z_open</code>) fails, the owned object will be set to its null state.</li><li>The <code>z_drop</code> releases the resources of the owned object and sets it to the null state to avoid double drop. Calling <code>z_drop</code> on an object in a null state is safe and does nothing.</li><li>Calling z_drop on an uninitialized object is invalid.</li></ul><p>Owned types support move semantics, which will consume the owned object and turn it into a moved object, see next section.</p><h3 id=moved-types>Moved types</h3><p>Moved types are obtained when using <code>z_move</code> on an owned type object. They are consumed on use when passed to relevant functions. Any non-constructor function accepting a moved object (i.e. an object passed by owned pointer) becomes responsible for calling drop on it. The object is guaranteed to be in the null state upon such function return, even if it fails.</p><h3 id=loaned-types>Loaned types</h3><p>Each owned type now has a corresponding <code>z_loaned_xxx_t</code> type, which is obtained by calling</p><p><code>z_loan</code> or <code>z_loan_mut</code> on it, or eventually received from Zenoh functions / callbacks.</p><p>It is no longer possible to directly access the fields of an owned object that has been loaned, the accessor functions on the loaned objects should instead be used.</p><p>Here is a quick example:</p><ul><li>Zenoh 0.11.x</li></ul><div class=highlight><pre tabindex=0 style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#078;font-weight:700>void</span> <span style=color:#c0f>reply_handler</span>(z_owned_reply_t <span style=color:#555>*</span>reply, <span style=color:#078;font-weight:700>void</span> <span style=color:#555>*</span>ctx) {
</span></span><span style=display:flex><span>    <span style=color:#069;font-weight:700>if</span> (z_reply_is_ok(reply)) {
</span></span><span style=display:flex><span>        z_sample_t sample <span style=color:#555>=</span> z_reply_ok(reply);
</span></span><span style=display:flex><span>        printf(<span style=color:#c30>&#34;&gt;&gt; Received (&#39;%.*s&#39;)</span><span style=color:#c30;font-weight:700>\n</span><span style=color:#c30>&#34;</span>, (<span style=color:#078;font-weight:700>int</span>)sample.payload.len, sample.payload.start);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>Zenoh 1.0.0</li></ul><div class=highlight><pre tabindex=0 style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#078;font-weight:700>void</span> <span style=color:#c0f>reply_handler</span>(<span style=color:#069;font-weight:700>const</span> z_loaned_reply_t <span style=color:#555>*</span>reply, <span style=color:#078;font-weight:700>void</span> <span style=color:#555>*</span>ctx) {
</span></span><span style=display:flex><span>    <span style=color:#069;font-weight:700>if</span> (z_reply_is_ok(reply)) {
</span></span><span style=display:flex><span>        <span style=color:#069;font-weight:700>const</span> z_loaned_sample_t <span style=color:#555>*</span>sample <span style=color:#555>=</span> z_reply_ok(reply);
</span></span><span style=display:flex><span>        z_owned_string_t replystr;
</span></span><span style=display:flex><span>        z_bytes_deserialize_into_string(z_sample_payload(sample), <span style=color:#555>&amp;</span>replystr);
</span></span><span style=display:flex><span>        printf(<span style=color:#c30>&#34;&gt;&gt; Received (&#39;%s&#39;)</span><span style=color:#c30;font-weight:700>\n</span><span style=color:#c30>&#34;</span>, z_string_data(z_loan(replystr)));
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Certain loaned types can be copied into owned, using the <code>z_clone</code> function.
All objects that can be cloned will have a function with the signature <code>z_xxx_clone</code>.
Please consult the docs of each type to determine if it can be copied into owned</p><div class=highlight><pre tabindex=0 style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#078;font-weight:700>void</span> <span style=color:#c0f>reply_handler</span>(<span style=color:#069;font-weight:700>const</span> z_loaned_reply_t <span style=color:#555>*</span>reply, <span style=color:#078;font-weight:700>void</span> <span style=color:#555>*</span>ctx) {
</span></span><span style=display:flex><span>    some_struct_t <span style=color:#555>*</span>some_ctx <span style=color:#555>=</span> (some_struct_t <span style=color:#555>*</span>)(ctx);
</span></span><span style=display:flex><span>    z_clone(some_ctx<span style=color:#555>-&gt;</span>query, query);
</span></span><span style=display:flex><span>    some_ctx<span style=color:#555>-&gt;</span>has_query <span style=color:#555>=</span> <span style=color:#366>true</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>In the case of our callback, this allows the data from the loaned type to be used in another thread context. Note that this other thread should not forget to call <code>z_drop</code> to avoid a memory leak!</p><h3 id=view-types>View types</h3><p>View types are only wrappers to user allocated data, like <code>z_view_keyexpr_t.</code> These types can be loaned in the same way as owned types but they don’t need to be dropped explicitly (user is fully responsible for deallocation of wrapped data).</p><ul><li>Zenoh 0.11.x</li></ul><div class=highlight><pre tabindex=0 style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#069;font-weight:700>const</span> <span style=color:#078;font-weight:700>char</span> <span style=color:#555>*</span>keyexpr <span style=color:#555>=</span> <span style=color:#c30>&#34;example/demo/*&#34;</span>;
</span></span><span style=display:flex><span>z_owned_subscriber_t sub <span style=color:#555>=</span> z_declare_subscriber(z_loan(session), z_keyexpr(keyexpr), z_move(callback), <span style=color:#366>NULL</span>);
</span></span><span style=display:flex><span><span style=color:#069;font-weight:700>if</span> (<span style=color:#555>!</span>z_check(sub)) {
</span></span><span style=display:flex><span>    printf(<span style=color:#c30>&#34;Unable to declare subscriber.</span><span style=color:#c30;font-weight:700>\n</span><span style=color:#c30>&#34;</span>);
</span></span><span style=display:flex><span>    <span style=color:#069;font-weight:700>return</span> <span style=color:#555>-</span><span style=color:#f60>1</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>Zenoh 1.0.0</li></ul><div class=highlight><pre tabindex=0 style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#069;font-weight:700>const</span> <span style=color:#078;font-weight:700>char</span> <span style=color:#555>*</span>keyexpr <span style=color:#555>=</span> <span style=color:#c30>&#34;example/demo/*&#34;</span>;
</span></span><span style=display:flex><span>z_owned_subscriber_t sub;
</span></span><span style=display:flex><span>z_view_keyexpr_t ke;
</span></span><span style=display:flex><span>z_view_keyexpr_from_str(<span style=color:#555>&amp;</span>ke, keyexpr);
</span></span><span style=display:flex><span><span style=color:#069;font-weight:700>if</span> (z_declare_subscriber(<span style=color:#555>&amp;</span>sub, z_loan(session), z_loan(ke), z_move(callback), <span style=color:#366>NULL</span>) <span style=color:#555>&lt;</span> <span style=color:#f60>0</span>) {
</span></span><span style=display:flex><span>    <span style=color:#069;font-weight:700>return</span> <span style=color:#555>-</span><span style=color:#f60>1</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=payload-and-serialization>Payload and Serialization</h2><p>Zenoh 1.0.0 handles payload differently. Before one would pass the pointer to the buffer and its length, now everything must be serialized into <code>z_owned_bytes_t</code>.</p><p>To simplify serialization/deserialization we provide support for some primitive types like <code>uint8_t*</code> + length, (null-)terminated strings and arithmetic types.</p><ul><li>Zenoh 0.11.x</li></ul><div class=highlight><pre tabindex=0 style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#078;font-weight:700>char</span> <span style=color:#555>*</span>value <span style=color:#555>=</span> <span style=color:#c30>&#34;Some data to publish on Zenoh&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#069;font-weight:700>if</span> (z_put(z_loan(session), z_keyexpr(ke), (<span style=color:#069;font-weight:700>const</span> <span style=color:#078;font-weight:700>uint8_t</span> <span style=color:#555>*</span>)value, strlen(value), <span style=color:#366>NULL</span>) <span style=color:#555>&lt;</span> <span style=color:#f60>0</span>) {
</span></span><span style=display:flex><span>    <span style=color:#069;font-weight:700>return</span> <span style=color:#555>-</span><span style=color:#f60>1</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>Zenoh 1.0.0</li></ul><div class=highlight><pre tabindex=0 style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#078;font-weight:700>char</span> <span style=color:#555>*</span>value <span style=color:#555>=</span> <span style=color:#c30>&#34;Some data to publish on Zenoh&#34;</span>;
</span></span><span style=display:flex><span>z_owned_bytes_t payload;
</span></span><span style=display:flex><span>z_bytes_serialize_from_str(<span style=color:#555>&amp;</span>payload, value);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#069;font-weight:700>if</span> (z_put(z_loan(session), z_loan(ke), z_move(payload), <span style=color:#366>NULL</span>) <span style=color:#555>&lt;</span> <span style=color:#f60>0</span>) {
</span></span><span style=display:flex><span>  <span style=color:#069;font-weight:700>return</span> <span style=color:#555>-</span><span style=color:#f60>1</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>To implement custom (de-)serialization functions, Zenoh 1.0.0 provides <code>z_bytes_iterator_t</code>, <code>z_bytes_reader_t</code> and <code>z_owned_bytes_wrtiter_t</code> types and corresponding functions.
Alternatively, it is always possible to perform serialization separately and only send/receive <code>uint8_t</code> arrays, by only calling trivial <code>z_bytes_serialize_from_slice</code> and <code>z_bytes_deserialize_into_slice</code> functions:</p><div class=highlight><pre tabindex=0 style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#078;font-weight:700>void</span> <span style=color:#c0f>send_data</span>(<span style=color:#069;font-weight:700>const</span> z_loaned_publisher_t<span style=color:#555>*</span> pub, <span style=color:#069;font-weight:700>const</span> <span style=color:#078;font-weight:700>uint8_t</span> <span style=color:#555>*</span>data, size_t len) {
</span></span><span style=display:flex><span>  z_owned_bytes_t payload;
</span></span><span style=display:flex><span>  z_bytes_serialize_from_buf(<span style=color:#555>&amp;</span>payload, data, len);
</span></span><span style=display:flex><span>  z_publisher_put(pub, z_move(payload), <span style=color:#366>NULL</span>);
</span></span><span style=display:flex><span>  <span style=color:#09f;font-style:italic>// no need to drop the payload, since it is consumed by z_publisher_put
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#078;font-weight:700>void</span> <span style=color:#c0f>receive_data</span>(<span style=color:#069;font-weight:700>const</span> z_loaned_bytes_t<span style=color:#555>*</span> payload) {
</span></span><span style=display:flex><span>  z_owned_slice_t slice;
</span></span><span style=display:flex><span>  z_bytes_deserialize_into_slice(payload, <span style=color:#555>&amp;</span>slice);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#09f;font-style:italic>// do something with serialized data
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span>  <span style=color:#09f;font-style:italic>// raw ptr can be accessed via z_slice_data(z_loan(slice))
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span>  <span style=color:#09f;font-style:italic>// data length can be accessed via z_slice_len(z_loan(slice))
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span>
</span></span><span style=display:flex><span>  <span style=color:#09f;font-style:italic>// in the end slice should be dropped since it contains a copy of the payload data
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span>  z_drop(z_move(slice));
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Note that it is no longer possible to access the underlying payload data pointer directly, since Zenoh cannot guarantee that the data is delivered as a single fragment.
So in order to get access to raw payload data one must use <code>z_bytes_reader_t</code> and related functions:</p><div class=highlight><pre tabindex=0 style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>z_bytes_reader_t reader <span style=color:#555>=</span> z_bytes_get_reader(z_loan(payload));
</span></span><span style=display:flex><span><span style=color:#078;font-weight:700>uint8_t</span> data1[<span style=color:#f60>10</span>] <span style=color:#555>=</span> {<span style=color:#f60>0</span>};
</span></span><span style=display:flex><span><span style=color:#078;font-weight:700>uint8_t</span> data2[<span style=color:#f60>20</span>] <span style=color:#555>=</span> {<span style=color:#f60>0</span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>z_bytes_reader_read(<span style=color:#555>&amp;</span>reader, data1, <span style=color:#f60>10</span>); <span style=color:#09f;font-style:italic>// copy first 10 payload bytes to data1
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span>z_bytes_reader_read(<span style=color:#555>&amp;</span>reader, data2, <span style=color:#f60>20</span>); <span style=color:#09f;font-style:italic>// copy next 20 payload bytes to data2
</span></span></span></code></pre></div><p>Note that all <code>z_bytes_serialize_from…</code> functions involve copying the data.
On the other hand, it is also possible to allow Zenoh to consume your data directly (which avoids the need to make an extra copy) using <code>z_bytes_from_buf</code> or <code>z_bytes_from_str</code>.
The user would need to provide a delete function to be called on data, when Zenoh finishes its processing:</p><div class=highlight><pre tabindex=0 style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#078;font-weight:700>void</span> <span style=color:#c0f>my_custom_delete_function</span>(<span style=color:#078;font-weight:700>void</span> <span style=color:#555>*</span>data, <span style=color:#078;font-weight:700>void</span><span style=color:#555>*</span> context) {
</span></span><span style=display:flex><span>  <span style=color:#09f;font-style:italic>// perform delete of data by optionally using extra information in the context
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span>  free(data);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#078;font-weight:700>void</span> <span style=color:#c0f>send_move_data</span>(<span style=color:#069;font-weight:700>const</span> z_loaned_publisher_t <span style=color:#555>*</span>publisher) {
</span></span><span style=display:flex><span>  <span style=color:#078;font-weight:700>uint8_t</span> <span style=color:#555>*</span>my_data <span style=color:#555>=</span> malloc(<span style=color:#f60>10</span>);
</span></span><span style=display:flex><span>  <span style=color:#09f;font-style:italic>// fill my_data as necessary
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span>  z_owned_bytes_t b;
</span></span><span style=display:flex><span>  z_bytes_from_buf(<span style=color:#555>&amp;</span>b, my_data, <span style=color:#f60>10</span>, my_custom_delete_function, <span style=color:#366>NULL</span>);
</span></span><span style=display:flex><span>  z_publisher_put(publisher, z_move(b));
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#09f;font-style:italic>// an example of sending a data with more complex destructor
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic>// a case of std::vector&lt;uint8_t&gt; from c++ stl library
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#078;font-weight:700>void</span> <span style=color:#c0f>delete_vector</span>(<span style=color:#078;font-weight:700>void</span> <span style=color:#555>*</span>data, <span style=color:#078;font-weight:700>void</span><span style=color:#555>*</span> context) {
</span></span><span style=display:flex><span>  std<span style=color:#555>::</span>vector<span style=color:#555>&lt;</span><span style=color:#078;font-weight:700>uint8_t</span><span style=color:#555>&gt;</span> <span style=color:#555>*</span>v <span style=color:#555>=</span> (std<span style=color:#555>::</span>vector<span style=color:#555>&lt;</span><span style=color:#078;font-weight:700>uint8_t</span><span style=color:#555>&gt;</span> <span style=color:#555>*</span>)context;
</span></span><span style=display:flex><span>  delete v;
</span></span><span style=display:flex><span>  <span style=color:#09f;font-style:italic>// in this case data pointer is not used for destruction
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#078;font-weight:700>void</span> <span style=color:#c0f>send_move_vector</span>(std<span style=color:#555>::</span>vector<span style=color:#555>&lt;</span><span style=color:#078;font-weight:700>uint8_t</span><span style=color:#555>&gt;</span> <span style=color:#555>*</span>v, <span style=color:#069;font-weight:700>const</span> z_loaned_publisher_t <span style=color:#555>*</span>publisher) {
</span></span><span style=display:flex><span>  z_owned_bytes_t b;
</span></span><span style=display:flex><span>  z_bytes_from_buf(<span style=color:#555>&amp;</span>b, v.data(), v.size(), delete_vector, (<span style=color:#078;font-weight:700>void</span><span style=color:#555>*</span>)v);
</span></span><span style=display:flex><span>  z_publisher_put(publisher, z_move(b));
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Yet another alternative is to send the statically allocated constant data (hence that does not require to be deleted) without making an extra copy. This can be achieved using the <code>z_serialize_from_static_buf</code> or <code>z_serialize_from_static_str</code> functions:</p><div class=highlight><pre tabindex=0 style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#069;font-weight:700>const</span> <span style=color:#078;font-weight:700>char</span> <span style=color:#555>*</span>my_constant_string <span style=color:#555>=</span> <span style=color:#c30>&#34;my string&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#078;font-weight:700>void</span> <span style=color:#c0f>send_static_data</span>(<span style=color:#069;font-weight:700>const</span> z_loaned_publisher_t <span style=color:#555>*</span>publisher) {
</span></span><span style=display:flex><span>  z_owned_bytes_t b;
</span></span><span style=display:flex><span>  z_bytes_from_static_str(<span style=color:#555>&amp;</span>b, my_constant_string);
</span></span><span style=display:flex><span>  z_publisher_put(publisher, z_move(b));
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=channel-handlers-and-callbacks>Channel Handlers and Callbacks</h2><p>In version 0.11.0 Channel handlers were only supported for <code>z_get</code>and <code>z_owned_queryable_t</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#09f;font-style:italic>// callback
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span>z_owned_closure_reply_t callback <span style=color:#555>=</span> z_closure(reply_handler);
</span></span><span style=display:flex><span>z_get(z_loan(session), z_keyexpr(keyexpr), <span style=color:#c30>&#34;&#34;</span>, z_move(callback), <span style=color:#555>&amp;</span>opts);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#09f;font-style:italic>// Channel handlers interface
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic>// blocking
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span>z_owned_reply_channel_t channel <span style=color:#555>=</span> zc_reply_fifo_new(<span style=color:#f60>16</span>);
</span></span><span style=display:flex><span>z_get(z_loan(session), z_keyexpr(keyexpr), <span style=color:#c30>&#34;&#34;</span>, z_move(channel.send), <span style=color:#555>&amp;</span>opts);
</span></span><span style=display:flex><span>z_owned_reply_t reply <span style=color:#555>=</span> z_reply_null();
</span></span><span style=display:flex><span><span style=color:#069;font-weight:700>for</span> (z_call(channel.recv, <span style=color:#555>&amp;</span>reply); z_check(reply); z_call(channel.recv, <span style=color:#555>&amp;</span>reply)) {
</span></span><span style=display:flex><span>    <span style=color:#069;font-weight:700>if</span> (z_reply_is_ok(<span style=color:#555>&amp;</span>reply)) {
</span></span><span style=display:flex><span>      z_sample_t sample <span style=color:#555>=</span> z_reply_ok(<span style=color:#555>&amp;</span>reply);
</span></span><span style=display:flex><span>      <span style=color:#09f;font-style:italic>// do something with sample and keystr
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span>    } <span style=color:#069;font-weight:700>else</span> {
</span></span><span style=display:flex><span>      printf(<span style=color:#c30>&#34;Received an error</span><span style=color:#c30;font-weight:700>\n</span><span style=color:#c30>&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    z_drop(z_move(reply));
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>z_drop(z_move(channel));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#09f;font-style:italic>// non-blocking
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span>z_owned_reply_channel_t channel <span style=color:#555>=</span> zc_reply_non_blocking_fifo_new(<span style=color:#f60>16</span>);
</span></span><span style=display:flex><span>z_get(z_loan(s), keyexpr, <span style=color:#c30>&#34;&#34;</span>, z_move(channel.send), <span style=color:#555>&amp;</span>opts);
</span></span><span style=display:flex><span>z_owned_reply_t reply <span style=color:#555>=</span> z_reply_null();
</span></span><span style=display:flex><span><span style=color:#069;font-weight:700>for</span> (<span style=color:#078;font-weight:700>bool</span> call_success <span style=color:#555>=</span> z_call(channel.recv, <span style=color:#555>&amp;</span>reply); <span style=color:#555>!</span>call_success <span style=color:#555>||</span> z_check(reply);
</span></span><span style=display:flex><span>    call_success <span style=color:#555>=</span> z_call(channel.recv, <span style=color:#555>&amp;</span>reply)) {
</span></span><span style=display:flex><span>    <span style=color:#069;font-weight:700>if</span> (<span style=color:#555>!</span>call_success) {
</span></span><span style=display:flex><span>        <span style=color:#069;font-weight:700>continue</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#069;font-weight:700>if</span> (z_reply_is_ok(z_loan(reply))) {
</span></span><span style=display:flex><span>      <span style=color:#069;font-weight:700>const</span> z_loaned_sample_t <span style=color:#555>*</span>sample <span style=color:#555>=</span> z_reply_ok(<span style=color:#555>&amp;</span>reply);
</span></span><span style=display:flex><span>      <span style=color:#09f;font-style:italic>// do something with sample
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span>    } <span style=color:#069;font-weight:700>else</span> {
</span></span><span style=display:flex><span>      printf(<span style=color:#c30>&#34;Received an error</span><span style=color:#c30;font-weight:700>\n</span><span style=color:#c30>&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    z_drop(z_move(reply));
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>z_drop(z_move(channel));
</span></span></code></pre></div><p>In 1.0.0, <code>z_owned_subscriber_t</code>, <code>z_owned_queryable_t</code> and <code>z_get</code> can use either a callable object or a stream handler. In addition, the same handler type now provides both a blocking and non-blocking interface. For the time being Zenoh provides 2 types of handlers:</p><ul><li><code>FifoHandler</code> - serving messages in Fifo order, <em>dropping new messages</em> once full. It is worth noting that it will drop new messages only if the queue is full and the default multi-thread feature is disabled.</li><li><code>RingHandler</code> - serving messages in Fifo order, <em>dropping older messages</em> once full to make room for new ones.</li></ul><div class=highlight><pre tabindex=0 style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#09f;font-style:italic>// callback
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span>z_owned_closure_reply_t callback <span style=color:#555>=</span> z_closure(reply_handler);
</span></span><span style=display:flex><span>z_get(z_loan(session), z_keyexpr(keyexpr), <span style=color:#c30>&#34;&#34;</span>, z_move(callback), <span style=color:#555>&amp;</span>opts);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#09f;font-style:italic>// stream handlers interface
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span>z_owned_fifo_handler_reply_t handler;
</span></span><span style=display:flex><span>z_owned_closure_reply_t closure;
</span></span><span style=display:flex><span>z_fifo_channel_reply_new(<span style=color:#555>&amp;</span>closure, <span style=color:#555>&amp;</span>handler, <span style=color:#f60>16</span>);
</span></span><span style=display:flex><span>z_get(z_loan(s), z_loan(keyexpr), <span style=color:#c30>&#34;&#34;</span>, z_move(closure), z_move(opts));
</span></span><span style=display:flex><span>z_owned_reply_t reply;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#09f;font-style:italic>// blocking
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span><span style=color:#069;font-weight:700>while</span> (z_recv(z_loan(handler), <span style=color:#555>&amp;</span>reply) <span style=color:#555>==</span> Z_OK) {
</span></span><span style=display:flex><span>    <span style=color:#09f;font-style:italic>// z_recv will block until there is at least one sample in the Fifo buffer
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span>    <span style=color:#069;font-weight:700>if</span> (z_reply_is_ok(z_loan(reply))) {
</span></span><span style=display:flex><span>        <span style=color:#069;font-weight:700>const</span> z_loaned_sample_t <span style=color:#555>*</span>sample <span style=color:#555>=</span> z_reply_ok(z_loan(reply));
</span></span><span style=display:flex><span>        <span style=color:#09f;font-style:italic>// do something with sample
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span>    } <span style=color:#069;font-weight:700>else</span> {
</span></span><span style=display:flex><span>        printf(<span style=color:#c30>&#34;Received an error</span><span style=color:#c30;font-weight:700>\n</span><span style=color:#c30>&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    z_drop(z_move(reply));
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#09f;font-style:italic>// non-blocking
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span><span style=color:#069;font-weight:700>while</span> (<span style=color:#366>true</span>) {
</span></span><span style=display:flex><span>    z_result_t res <span style=color:#555>=</span> z_try_recv(z_loan(handler), <span style=color:#555>&amp;</span>reply);
</span></span><span style=display:flex><span>    <span style=color:#069;font-weight:700>if</span> (res <span style=color:#555>==</span> Z_CHANNEL_NODATA) {
</span></span><span style=display:flex><span>      <span style=color:#09f;font-style:italic>// z_try_recv is non-blocking call, so will fail to return a reply if the Fifo buffer is empty
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span>      <span style=color:#09f;font-style:italic>// do some other work or just sleep
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span>    } <span style=color:#069;font-weight:700>else</span> <span style=color:#069;font-weight:700>if</span> (res <span style=color:#555>==</span> Z_OK) {
</span></span><span style=display:flex><span>      <span style=color:#069;font-weight:700>if</span> (z_reply_is_ok(z_loan(reply))) {
</span></span><span style=display:flex><span>          <span style=color:#069;font-weight:700>const</span> z_loaned_sample_t <span style=color:#555>*</span>sample <span style=color:#555>=</span> z_reply_ok(z_loan(reply));
</span></span><span style=display:flex><span>          <span style=color:#09f;font-style:italic>// do something with sample
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span>      } <span style=color:#069;font-weight:700>else</span> {
</span></span><span style=display:flex><span>          printf(<span style=color:#c30>&#34;Received an error</span><span style=color:#c30;font-weight:700>\n</span><span style=color:#c30>&#34;</span>);
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>      z_drop(z_move(reply));
</span></span><span style=display:flex><span>     } <span style=color:#069;font-weight:700>else</span> { <span style=color:#09f;font-style:italic>// res == Z_CHANNEL_DISCONNECTED
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span>       <span style=color:#069;font-weight:700>break</span>; <span style=color:#09f;font-style:italic>// channel is closed - no more replies will arrive
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span>     }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The same now also works for <code>Subscriber</code> and <code>Queryable</code> :</p><div class=highlight><pre tabindex=0 style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#09f;font-style:italic>// callback
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic>// callback
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span><span style=color:#078;font-weight:700>void</span> <span style=color:#c0f>data_handler</span>(<span style=color:#069;font-weight:700>const</span> z_loaned_sample_t <span style=color:#555>*</span>sample, <span style=color:#078;font-weight:700>void</span> <span style=color:#555>*</span>context) {
</span></span><span style=display:flex><span>  <span style=color:#09f;font-style:italic>// do something with sample
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>z_owned_closure_sample_t callback;
</span></span><span style=display:flex><span>z_closure(<span style=color:#555>&amp;</span>callback, data_handler, <span style=color:#366>NULL</span>, <span style=color:#366>NULL</span>);
</span></span><span style=display:flex><span>z_owned_subscriber_t sub;
</span></span><span style=display:flex><span><span style=color:#069;font-weight:700>if</span> (z_declare_subscriber(<span style=color:#555>&amp;</span>sub, z_loan(session), z_loan(keyexpr), z_move(callback), <span style=color:#366>NULL</span>) <span style=color:#555>&lt;</span> <span style=color:#f60>0</span>) {
</span></span><span style=display:flex><span>  printf(<span style=color:#c30>&#34;Unable to declare subscriber.</span><span style=color:#c30;font-weight:700>\n</span><span style=color:#c30>&#34;</span>);
</span></span><span style=display:flex><span>  exit(<span style=color:#555>-</span><span style=color:#f60>1</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#09f;font-style:italic>// stream handlers interface
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span>z_owned_fifo_handler_sample_t handler;
</span></span><span style=display:flex><span>z_owned_closure_sample_t closure;
</span></span><span style=display:flex><span>z_fifo_channel_reply_new(<span style=color:#555>&amp;</span>closure, <span style=color:#555>&amp;</span>handler, <span style=color:#f60>16</span>);
</span></span><span style=display:flex><span>z_owned_subscriber_t sub;
</span></span><span style=display:flex><span><span style=color:#069;font-weight:700>if</span> (z_declare_subscriber(<span style=color:#555>&amp;</span>sub, z_loan(session), z_loan(keyexpr), z_move(closure), <span style=color:#366>NULL</span>) <span style=color:#555>&lt;</span> <span style=color:#f60>0</span>) {
</span></span><span style=display:flex><span>  printf(<span style=color:#c30>&#34;Unable to declare subscriber.</span><span style=color:#c30;font-weight:700>\n</span><span style=color:#c30>&#34;</span>);
</span></span><span style=display:flex><span>  exit(<span style=color:#555>-</span><span style=color:#f60>1</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>z_owned_sample_t sample;
</span></span><span style=display:flex><span><span style=color:#09f;font-style:italic>// blocking
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span><span style=color:#069;font-weight:700>while</span> (z_recv(z_loan(handler), <span style=color:#555>&amp;</span>sample) <span style=color:#555>==</span> Z_OK) {
</span></span><span style=display:flex><span>    <span style=color:#09f;font-style:italic>// z_recv will block until there is at least one sample in the Fifo buffer
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span>    <span style=color:#09f;font-style:italic>// it will return an empty sample and is_alive=false once subscriber gets disconnected
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span>
</span></span><span style=display:flex><span>    <span style=color:#09f;font-style:italic>// do something with sample
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span>    z_drop(z_move(sample));
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#09f;font-style:italic>// non-blocking
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span><span style=color:#069;font-weight:700>while</span> (<span style=color:#366>true</span>) {
</span></span><span style=display:flex><span>    z_result_t res <span style=color:#555>=</span> z_try_recv(z_loan(handler), <span style=color:#555>&amp;</span>sample);
</span></span><span style=display:flex><span>    <span style=color:#069;font-weight:700>if</span> (res <span style=color:#555>==</span> Z_CHANNEL_NODATA) {
</span></span><span style=display:flex><span>      <span style=color:#09f;font-style:italic>// z_try_recv is non-blocking call, so will fail to return a sample if the Fifo buffer is empty
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span>      <span style=color:#09f;font-style:italic>// do some other work or just sleep
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span>    } <span style=color:#069;font-weight:700>else</span> <span style=color:#069;font-weight:700>if</span> (res <span style=color:#555>==</span> Z_OK) {
</span></span><span style=display:flex><span>      <span style=color:#09f;font-style:italic>// do something with sample
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span>      z_drop(z_move(sample));
</span></span><span style=display:flex><span>    } <span style=color:#069;font-weight:700>else</span> { <span style=color:#09f;font-style:italic>// res == Z_CHANNEL_DISCONNECTED
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span>      <span style=color:#069;font-weight:700>break</span>; <span style=color:#09f;font-style:italic>// channel is closed - no more samples will be received
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The <code>z_owned_pull_subscriber_t</code> was removed, given that <code>RingHandler</code> can provide similar functionality with ordinary <code>z_owned_subscriber_t.</code>
Since the callback in 1.0.0. carries a loaned sample whenever it is triggered, we can save an explicit drop on the sample now.</p><h2 id=attachment>Attachment</h2><p>In 0.11.0, attachments were a separate type and could only be a set of key-value pairs:</p><div class=highlight><pre tabindex=0 style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#09f;font-style:italic>// publish message with attachment
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span><span style=color:#078;font-weight:700>char</span> <span style=color:#555>*</span>value <span style=color:#555>=</span> <span style=color:#c30>&#34;Some data to publish on Zenoh&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>z_put_options_t options <span style=color:#555>=</span> z_put_options_default();
</span></span><span style=display:flex><span>z_owned_bytes_map_t map <span style=color:#555>=</span> z_bytes_map_new();
</span></span><span style=display:flex><span>z_bytes_map_insert_by_alias(<span style=color:#555>&amp;</span>map, _z_bytes_wrap((<span style=color:#078;font-weight:700>uint8_t</span> <span style=color:#555>*</span>)<span style=color:#c30>&#34;test&#34;</span>, <span style=color:#f60>2</span>), _z_bytes_wrap((<span style=color:#078;font-weight:700>uint8_t</span> <span style=color:#555>*</span>)<span style=color:#c30>&#34;attachement&#34;</span>, <span style=color:#f60>5</span>));
</span></span><span style=display:flex><span>options.attachment <span style=color:#555>=</span> z_bytes_map_as_attachment(<span style=color:#555>&amp;</span>map);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#069;font-weight:700>if</span> (z_put(z_loan(s), z_keyexpr(keyexpr), (<span style=color:#069;font-weight:700>const</span> <span style=color:#078;font-weight:700>uint8_t</span> <span style=color:#555>*</span>)value, strlen(value), <span style=color:#555>&amp;</span>options) <span style=color:#555>&lt;</span> <span style=color:#f60>0</span>) {
</span></span><span style=display:flex><span>    <span style=color:#069;font-weight:700>return</span> <span style=color:#555>-</span><span style=color:#f60>1</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>z_bytes_map_drop(<span style=color:#555>&amp;</span>map);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#09f;font-style:italic>// receive sample with attachment
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#078;font-weight:700>int8_t</span> <span style=color:#c0f>attachment_reader</span>(z_bytes_t key, z_bytes_t val, <span style=color:#078;font-weight:700>void</span><span style=color:#555>*</span> ctx) {
</span></span><span style=display:flex><span>    printf(<span style=color:#c30>&#34;   attachment: %.*s: &#39;%.*s&#39;</span><span style=color:#c30;font-weight:700>\n</span><span style=color:#c30>&#34;</span>, (<span style=color:#078;font-weight:700>int</span>)key.len, key.start, (<span style=color:#078;font-weight:700>int</span>)val.len, val.start);
</span></span><span style=display:flex><span>    <span style=color:#069;font-weight:700>return</span> <span style=color:#f60>0</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#078;font-weight:700>void</span> <span style=color:#c0f>data_handler</span>(<span style=color:#069;font-weight:700>const</span> z_sample_t<span style=color:#555>*</span> sample, <span style=color:#078;font-weight:700>void</span><span style=color:#555>*</span> arg) {
</span></span><span style=display:flex><span>    <span style=color:#09f;font-style:italic>// checks if attachment exists
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span>    <span style=color:#069;font-weight:700>if</span> (z_check(sample<span style=color:#555>-&gt;</span>attachment)) {
</span></span><span style=display:flex><span>        <span style=color:#09f;font-style:italic>// reads full attachment
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span>        z_attachment_iterate(sample<span style=color:#555>-&gt;</span>attachment, attachment_reader, <span style=color:#366>NULL</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#09f;font-style:italic>// reads particular attachment item
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span>        z_bytes_t index <span style=color:#555>=</span> z_attachment_get(sample<span style=color:#555>-&gt;</span>attachment, z_bytes_from_str(<span style=color:#c30>&#34;index&#34;</span>));
</span></span><span style=display:flex><span>        <span style=color:#069;font-weight:700>if</span> (z_check(index)) {
</span></span><span style=display:flex><span>            printf(<span style=color:#c30>&#34;   message number: %.*s</span><span style=color:#c30;font-weight:700>\n</span><span style=color:#c30>&#34;</span>, (<span style=color:#078;font-weight:700>int</span>)index.len, index.start);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    z_drop(z_move(keystr));
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>In 1.0.0, attachments were greatly simplified. They are now represented as <code>z_..._bytes_t</code> (i.e. the same type we use to represent serialized data) and can thus contain data in any format.</p><div class=highlight><pre tabindex=0 style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#09f;font-style:italic>// publish attachment
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span><span style=color:#069;font-weight:700>typedef</span> <span style=color:#069;font-weight:700>struct</span> {
</span></span><span style=display:flex><span>  <span style=color:#078;font-weight:700>char</span><span style=color:#555>*</span> key;
</span></span><span style=display:flex><span>  <span style=color:#078;font-weight:700>char</span><span style=color:#555>*</span> value;
</span></span><span style=display:flex><span>} kv_pair_t;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#069;font-weight:700>typedef</span> <span style=color:#069;font-weight:700>struct</span> kv_it {
</span></span><span style=display:flex><span>    kv_pair_t <span style=color:#555>*</span>current;
</span></span><span style=display:flex><span>    kv_pair_t <span style=color:#555>*</span>end;
</span></span><span style=display:flex><span>} kv_it;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#078;font-weight:700>bool</span> <span style=color:#c0f>create_attachment_iter</span>(z_owned_bytes_t<span style=color:#555>*</span> kv_pair, <span style=color:#078;font-weight:700>void</span><span style=color:#555>*</span> context) {
</span></span><span style=display:flex><span>  kv_it<span style=color:#555>*</span> it <span style=color:#555>=</span> (kv_it<span style=color:#555>*</span>)(context);
</span></span><span style=display:flex><span>  <span style=color:#069;font-weight:700>if</span> (it<span style=color:#555>-&gt;</span>current <span style=color:#555>==</span> it<span style=color:#555>-&gt;</span>end) {
</span></span><span style=display:flex><span>    <span style=color:#069;font-weight:700>return</span> <span style=color:#366>false</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  z_owned_bytes_t k, v;
</span></span><span style=display:flex><span>  <span style=color:#09f;font-style:italic>// serialize as key-value pair
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span>  z_bytes_serialize_from_str(<span style=color:#555>&amp;</span>k, it<span style=color:#555>-&gt;</span>current<span style=color:#555>-&gt;</span>key);
</span></span><span style=display:flex><span>  z_bytes_serialize_from_str(<span style=color:#555>&amp;</span>v, it<span style=color:#555>-&gt;</span>current<span style=color:#555>-&gt;</span>value);
</span></span><span style=display:flex><span>  z_bytes_serialize_from_pair(kv_pair, z_move(k), z_move(v));
</span></span><span style=display:flex><span>  it<span style=color:#555>-&gt;</span>current<span style=color:#555>++</span>;
</span></span><span style=display:flex><span>  <span style=color:#069;font-weight:700>return</span> <span style=color:#366>true</span>;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>kv_pair_t attachment_kvs[<span style=color:#f60>2</span>] <span style=color:#555>=</span> {;
</span></span><span style=display:flex><span>  (kv_pair_t){.key <span style=color:#555>=</span> <span style=color:#c30>&#34;index&#34;</span>, .value <span style=color:#555>=</span> <span style=color:#c30>&#34;1&#34;</span>},
</span></span><span style=display:flex><span>  (kv_pair_t){.key <span style=color:#555>=</span> <span style=color:#c30>&#34;source&#34;</span>, .value <span style=color:#555>=</span> <span style=color:#c30>&#34;C&#34;</span>}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>kv_it it <span style=color:#555>=</span> { .begin <span style=color:#555>=</span> attachment_kvs, .end <span style=color:#555>=</span> attachment_kvs <span style=color:#555>+</span> <span style=color:#f60>2</span> };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>z_owned_bytes_t payload, attachment;
</span></span><span style=display:flex><span><span style=color:#09f;font-style:italic>// serialzie key value pairs as attachment using z_bytes_serialize_from_iter
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span>z_bytes_serialize_from_iter(<span style=color:#555>&amp;</span>attachment, create_attachment_iter, (<span style=color:#078;font-weight:700>void</span><span style=color:#555>*</span>)<span style=color:#555>&amp;</span>it);
</span></span><span style=display:flex><span>options.attachment <span style=color:#555>=</span> <span style=color:#555>&amp;</span>attachment;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>z_bytes_serialize_from_str(<span style=color:#555>&amp;</span>payload, <span style=color:#c30>&#34;payload&#34;</span>);
</span></span><span style=display:flex><span>z_publisher_put(z_loan(pub), z_move(payload), <span style=color:#555>&amp;</span>options);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#09f;font-style:italic>// receive sample with attachment
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#078;font-weight:700>void</span> <span style=color:#c0f>data_handler</span>(<span style=color:#069;font-weight:700>const</span> z_loaned_sample_t <span style=color:#555>*</span>sample, <span style=color:#078;font-weight:700>void</span> <span style=color:#555>*</span>arg) {
</span></span><span style=display:flex><span>  z_view_string_t key_string;
</span></span><span style=display:flex><span>  z_keyexpr_as_view_string(z_sample_keyexpr(sample), <span style=color:#555>&amp;</span>key_string);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  z_owned_string_t payload_string;
</span></span><span style=display:flex><span>  z_bytes_deserialize_into_string(z_sample_payload(sample), <span style=color:#555>&amp;</span>payload_string);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  printf(<span style=color:#c30>&#34;&gt;&gt; [Subscriber] Received %s (&#39;%.*s&#39;: &#39;%.*s&#39;)</span><span style=color:#c30;font-weight:700>\n</span><span style=color:#c30>&#34;</span>, kind_to_str(z_sample_kind(sample)),
</span></span><span style=display:flex><span>   (<span style=color:#078;font-weight:700>int</span>)z_string_len(z_loan(key_string)), z_string_data(z_loan(key_string)),
</span></span><span style=display:flex><span>   (<span style=color:#078;font-weight:700>int</span>)z_string_len(z_loan(payload_string)), z_string_data(z_loan(payload_string)));
</span></span><span style=display:flex><span>  z_drop(z_move(payload_string));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#069;font-weight:700>const</span> z_loaned_bytes_t <span style=color:#555>*</span>attachment <span style=color:#555>=</span> z_sample_attachment(sample);
</span></span><span style=display:flex><span>  <span style=color:#09f;font-style:italic>// checks if attachment exists
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span>  <span style=color:#069;font-weight:700>if</span> (attachment <span style=color:#555>==</span> <span style=color:#366>NULL</span>) {
</span></span><span style=display:flex><span>    <span style=color:#069;font-weight:700>return</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#09f;font-style:italic>// read attachment key-value pairs using bytes_iterator
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span>  z_bytes_iterator_t iter <span style=color:#555>=</span> z_bytes_get_iterator(attachment);
</span></span><span style=display:flex><span>  z_owned_bytes_t kv;
</span></span><span style=display:flex><span>  <span style=color:#069;font-weight:700>while</span> (z_bytes_iterator_next(<span style=color:#555>&amp;</span>iter, <span style=color:#555>&amp;</span>kv)) {
</span></span><span style=display:flex><span>      z_owned_bytes_t k, v;
</span></span><span style=display:flex><span>      z_owned_string_t key, value;
</span></span><span style=display:flex><span>      z_bytes_deserialize_into_pair(z_loan(kv), <span style=color:#555>&amp;</span>k, <span style=color:#555>&amp;</span>v);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      z_bytes_deserialize_into_string(z_loan(k), <span style=color:#555>&amp;</span>key);
</span></span><span style=display:flex><span>      z_bytes_deserialize_into_string(z_loan(v), <span style=color:#555>&amp;</span>value);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      printf(<span style=color:#c30>&#34;   attachment: %.*s: &#39;%.*s&#39;</span><span style=color:#c30;font-weight:700>\n</span><span style=color:#c30>&#34;</span>,
</span></span><span style=display:flex><span>        (<span style=color:#078;font-weight:700>int</span>)z_string_len(z_loan(key)), z_string_data(z_loan(key)),
</span></span><span style=display:flex><span>        (<span style=color:#078;font-weight:700>int</span>)z_string_len(z_loan(value)), z_string_data(z_loan(value)));
</span></span><span style=display:flex><span>      z_drop(z_move(kv));
</span></span><span style=display:flex><span>      z_drop(z_move(k));
</span></span><span style=display:flex><span>      z_drop(z_move(v));
</span></span><span style=display:flex><span>      z_drop(z_move(key));
</span></span><span style=display:flex><span>      z_drop(z_move(value));
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=encoding>Encoding</h2><p>Encoding handling has been reworked: before one would use an enum id and a string suffix value, now only the encoding metadata needs to be registered using <code>z_encoding_from_str</code>.</p><p>There is a set of predefined constant encodings subject to some wire-level optimization. To benefit from this, the provided encoding should follow the format: <code>"&lt;predefined constant>;&lt;optional additional data>"</code></p><p>All predefined constants provided can be found in here <a href=https://github.com/eclipse-zenoh/zenoh-pico/blob/10ddde219be41fc0b43bad4d19f571625a27c161/src/api/api.c#L218-L285>Encoding Variants</a></p><ul><li>Zenoh 0.11.x</li></ul><div class=highlight><pre tabindex=0 style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#078;font-weight:700>char</span> <span style=color:#555>*</span>value <span style=color:#555>=</span> <span style=color:#c30>&#34;Some data to publish on Zenoh&#34;</span>;
</span></span><span style=display:flex><span>z_put_options_t options <span style=color:#555>=</span> z_put_options_default();
</span></span><span style=display:flex><span>options.encoding <span style=color:#555>=</span> z_encoding(Z_ENCODING_PREFIX_TEXT_PLAIN, <span style=color:#c30>&#34;utf8&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#069;font-weight:700>if</span> (z_put(z_loan(session), z_keyexpr(ke), (<span style=color:#069;font-weight:700>const</span> <span style=color:#078;font-weight:700>uint8_t</span> <span style=color:#555>*</span>)value, strlen(value), <span style=color:#555>&amp;</span>options) <span style=color:#555>&lt;</span> <span style=color:#f60>0</span>) {
</span></span><span style=display:flex><span>    <span style=color:#069;font-weight:700>return</span> <span style=color:#555>-</span><span style=color:#f60>1</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>Zenoh 1.0.0</li></ul><div class=highlight><pre tabindex=0 style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#078;font-weight:700>char</span> <span style=color:#555>*</span>value <span style=color:#555>=</span> <span style=color:#c30>&#34;Some data to publish on Zenoh&#34;</span>;
</span></span><span style=display:flex><span>z_owned_bytes_t payload;
</span></span><span style=display:flex><span>z_bytes_serialize_from_str(<span style=color:#555>&amp;</span>payload, value);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>z_publisher_put_options_t options;
</span></span><span style=display:flex><span>z_publisher_put_options_default(<span style=color:#555>&amp;</span>options);
</span></span><span style=display:flex><span>z_encoding_from_str(<span style=color:#555>&amp;</span>encoding, <span style=color:#c30>&#34;text/plain;utf8&#34;</span>);
</span></span><span style=display:flex><span>options.encoding <span style=color:#555>=</span> z_move(encoding);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#069;font-weight:700>if</span> (z_put(z_loan(session), z_loan(ke), z_move(payload), <span style=color:#555>&amp;</span>options) <span style=color:#555>&lt;</span> <span style=color:#f60>0</span>) {
</span></span><span style=display:flex><span>  <span style=color:#069;font-weight:700>return</span> <span style=color:#555>-</span><span style=color:#f60>1</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=timestamps>Timestamps</h2><p>The generation of timestamps is now tied to a Zenoh session, with the timestamp inheriting the <code>ZenohID</code> of the session.</p><ul><li>Zenoh 0.11.x</li></ul><div class=highlight><pre tabindex=0 style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#09f;font-style:italic>// Didn&#39;t exist
</span></span></span></code></pre></div><ul><li>Zenoh 1.0.0</li></ul><div class=highlight><pre tabindex=0 style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>z_timestamp_t ts;
</span></span><span style=display:flex><span>z_timestamp_new(<span style=color:#555>&amp;</span>ts, z_loan(s));
</span></span><span style=display:flex><span>options.timestamp <span style=color:#555>=</span> <span style=color:#555>&amp;</span>ts;
</span></span><span style=display:flex><span>z_publisher_put(z_loan(pub), z_move(payload), <span style=color:#555>&amp;</span>options);
</span></span></code></pre></div><h2 id=error-handling>Error Handling</h2><p>In 1.0.0, we unified the return type of Zenoh functions as <code>z_result_t</code>. For example,</p><ul><li>Zenoh 0.11.x</li></ul><div class=highlight><pre tabindex=0 style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#078;font-weight:700>int8_t</span> <span style=color:#c0f>z_put</span>(<span style=color:#069;font-weight:700>struct</span> z_session_t session,
</span></span><span style=display:flex><span>             <span style=color:#069;font-weight:700>struct</span> z_keyexpr_t keyexpr,
</span></span><span style=display:flex><span>             <span style=color:#069;font-weight:700>const</span> <span style=color:#078;font-weight:700>uint8_t</span> <span style=color:#555>*</span>payload,
</span></span><span style=display:flex><span>             size_t len,
</span></span><span style=display:flex><span>             <span style=color:#069;font-weight:700>const</span> <span style=color:#069;font-weight:700>struct</span> z_put_options_t <span style=color:#555>*</span>opts);
</span></span></code></pre></div><ul><li>Zenoh 1.0.0</li></ul><div class=highlight><pre tabindex=0 style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>z_result_t <span style=color:#c0f>z_put</span>(<span style=color:#069;font-weight:700>const</span> <span style=color:#069;font-weight:700>struct</span> z_loaned_session_t <span style=color:#555>*</span>session,
</span></span><span style=display:flex><span>                 <span style=color:#069;font-weight:700>const</span> <span style=color:#069;font-weight:700>struct</span> z_loaned_keyexpr_t <span style=color:#555>*</span>key_expr,
</span></span><span style=display:flex><span>                 <span style=color:#069;font-weight:700>struct</span> z_owned_bytes_t <span style=color:#555>*</span>payload,
</span></span><span style=display:flex><span>                 <span style=color:#069;font-weight:700>struct</span> z_put_options_t <span style=color:#555>*</span>options);
</span></span></code></pre></div><h2 id=keyexpr--string-conversion>KeyExpr / String Conversion</h2><p>In 1.0.0, we have reworked the conversion between key expressions and strings, illustrated below.</p><ul><li>Zenoh 0.11.x</li></ul><div class=highlight><pre tabindex=0 style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#09f;font-style:italic>// keyexpr =&gt; string
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span>z_owned_str_t keystr <span style=color:#555>=</span> z_keyexpr_to_string(z_loan(z_owned_keyexpr_t));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#09f;font-style:italic>// keyexpr =&gt; const char *
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span>z_loan(keystr)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#09f;font-style:italic>// const char* =&gt; keystr
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span>z_owned_keyexpr_t keyexpr <span style=color:#555>=</span> z_keyexpr_new(<span style=color:#069;font-weight:700>const</span> <span style=color:#078;font-weight:700>char</span><span style=color:#555>*</span>)
</span></span></code></pre></div><ul><li>Zenoh 1.0.0</li></ul><div class=highlight><pre tabindex=0 style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#09f;font-style:italic>// keyexpr =&gt; string
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span>z_view_string_t keystr;
</span></span><span style=display:flex><span>z_keyexpr_as_view_string(z_loan(z_owned_keyexpr_t), <span style=color:#555>&amp;</span>keystr);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#09f;font-style:italic>// z_view_string_t  =&gt; const char*
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span>z_string_data(z_loan(keystr))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#09f;font-style:italic>// const char* =&gt; keystr
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span>z_owned_keyexpr_t keyexpr;
</span></span><span style=display:flex><span>z_error_t res <span style=color:#555>=</span> z_keyexpr_from_string(<span style=color:#555>&amp;</span>keyexpr, <span style=color:#069;font-weight:700>const</span> <span style=color:#078;font-weight:700>char</span> <span style=color:#555>*</span>);
</span></span></code></pre></div><p>NOTE: Based on efficiency considerations, the char pointer of <code>z_string_data</code> might not be null-terminated in zenoh-c. To read the string data, we need to pair it with the length <code>z_string_len</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>z_view_str_t keystr;
</span></span><span style=display:flex><span>z_keyexpr_as_view_string(z_loan(keyexpr), <span style=color:#555>&amp;</span>keystr);
</span></span><span style=display:flex><span>printf(<span style=color:#c30>&#34;%.*s&#34;</span>, (<span style=color:#078;font-weight:700>int</span>)z_string_len(z_loan(keystr)), z_string_data(z_loan(keystr)));
</span></span></code></pre></div><p>And to compare the string with <code>strncmp</code> instead of <code>strcmp</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>z_view_str_t keystr;
</span></span><span style=display:flex><span>z_keyexpr_as_view_string(z_loan(keyexpr), <span style=color:#555>&amp;</span>keystr);
</span></span><span style=display:flex><span><span style=color:#069;font-weight:700>const</span> <span style=color:#078;font-weight:700>char</span><span style=color:#555>*</span> target <span style=color:#555>=</span> <span style=color:#c30>&#34;string&#34;</span>;
</span></span><span style=display:flex><span>strncmp(target, z_string_data(z_loan(keystr)), z_string_len(z_loan(keystr)));
</span></span></code></pre></div><h2 id=accessor-pattern>Accessor Pattern</h2><p>In 1.0.0, we have made our API more convenient and consistent to use across languages. We use opaque types to wrap the raw Zenoh data from the Rust library in zenoh-c. With this change, we introduce the accessor pattern to read the field of a struct.</p><p>For instance, to get the attachment of a sample in zenoh-c:</p><ul><li>0.11.0</li></ul><div class=highlight><pre tabindex=0 style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#069;font-weight:700>typedef</span> <span style=color:#069;font-weight:700>struct</span> z_sample_t {
</span></span><span style=display:flex><span>  <span style=color:#069;font-weight:700>struct</span> z_keyexpr_t keyexpr;
</span></span><span style=display:flex><span>  <span style=color:#069;font-weight:700>struct</span> z_bytes_t payload;
</span></span><span style=display:flex><span>  <span style=color:#069;font-weight:700>struct</span> z_encoding_t encoding;
</span></span><span style=display:flex><span>  <span style=color:#069;font-weight:700>const</span> <span style=color:#078;font-weight:700>void</span> <span style=color:#555>*</span>_zc_buf;
</span></span><span style=display:flex><span>  <span style=color:#069;font-weight:700>enum</span> z_sample_kind_t kind;
</span></span><span style=display:flex><span>  <span style=color:#069;font-weight:700>struct</span> z_timestamp_t timestamp;
</span></span><span style=display:flex><span>  <span style=color:#069;font-weight:700>struct</span> z_qos_t qos;
</span></span><span style=display:flex><span>  <span style=color:#069;font-weight:700>struct</span> z_attachment_t attachment;
</span></span><span style=display:flex><span>} z_sample_t;
</span></span></code></pre></div><ul><li>1.0.0</li></ul><p>Opaque type of <code>z_sample</code></p><div class=highlight><pre tabindex=0 style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#c30;font-style:italic>/// An owned Zenoh sample.
</span></span></span><span style=display:flex><span><span style=color:#c30;font-style:italic>///
</span></span></span><span style=display:flex><span><span style=color:#c30;font-style:italic>/// This is a read only type that can only be constructed by cloning a `z_loaned_sample_t`.
</span></span></span><span style=display:flex><span><span style=color:#c30;font-style:italic>/// Like all owned types, it should be freed using z_drop or z_sample_drop.
</span></span></span><span style=display:flex><span><span style=color:#c30;font-style:italic></span><span style=color:#099>#[derive(Copy, Clone)]</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#099>#[repr(C, align(8))]</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#069;font-weight:700>pub</span><span style=color:#bbb> </span><span style=color:#069;font-weight:700>struct</span> <span style=color:#0a8;font-weight:700>z_owned_sample_t</span><span style=color:#bbb> </span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>_0: [<span style=color:#078;font-weight:700>u8</span>;<span style=color:#bbb> </span><span style=color:#f60>224</span>],<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>}<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#c30;font-style:italic>/// A loaned Zenoh sample.
</span></span></span><span style=display:flex><span><span style=color:#c30;font-style:italic></span><span style=color:#099>#[derive(Copy, Clone)]</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#099>#[repr(C, align(8))]</span><span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#069;font-weight:700>pub</span><span style=color:#bbb> </span><span style=color:#069;font-weight:700>struct</span> <span style=color:#0a8;font-weight:700>z_loaned_sample_t</span><span style=color:#bbb> </span>{<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb>    </span>_0: [<span style=color:#078;font-weight:700>u8</span>;<span style=color:#bbb> </span><span style=color:#f60>224</span>],<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span>}<span style=color:#bbb>
</span></span></span></code></pre></div><p>Get attachment</p><div class=highlight><pre tabindex=0 style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#069;font-weight:700>const</span> <span style=color:#069;font-weight:700>struct</span> z_loaned_bytes_t <span style=color:#555>*</span><span style=color:#c0f>z_sample_attachment</span>(<span style=color:#069;font-weight:700>const</span> <span style=color:#069;font-weight:700>struct</span> z_loaned_sample_t <span style=color:#555>*</span>this_);
</span></span></code></pre></div><p>In zenoh-pico, we recommend users follow the accessor pattern even though the struct <code>z_sample_t</code> is explicitly defined in the library.</p><h2 id=usage-of-z_bytes_clone>Usage of <code>z_bytes_clone</code></h2><p>In short, <code>z_bytes_t</code> is made of reference-counted data slices. In 1.0.0, we aligned the implementation of <code>z_bytes_clone</code> and made it perform a shallow copy for improved efficiency.</p><ul><li>Zenoh 0.11.x</li></ul><div class=highlight><pre tabindex=0 style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>ZENOHC_API <span style=color:#069;font-weight:700>struct</span> zc_owned_payload_t <span style=color:#c0f>zc_sample_payload_rcinc</span>(<span style=color:#069;font-weight:700>const</span> <span style=color:#069;font-weight:700>struct</span> z_sample_t <span style=color:#555>*</span>sample);
</span></span></code></pre></div><ul><li>Zenoh 1.0.0</li></ul><div class=highlight><pre tabindex=0 style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>ZENOHC_API <span style=color:#078;font-weight:700>void</span> <span style=color:#c0f>z_bytes_clone</span>(<span style=color:#069;font-weight:700>struct</span> z_owned_bytes_t <span style=color:#555>*</span>dst, <span style=color:#069;font-weight:700>const</span> <span style=color:#069;font-weight:700>struct</span> z_loaned_bytes_t <span style=color:#555>*</span>this_);
</span></span></code></pre></div><p>NOTE: We don&rsquo;t offer a deep copy API. However, users can create a deep copy by deserializing the <code>z_bytes_t</code> into a zenoh object. For example, use <code>z_bytes_deserialize_into_slice</code> to deserialize it into a <code>z_owned_slice_t</code> and then call <code>z_slice_data</code> to obtain a pointer to <code>uint8_t</code> data.</p><h2 id=zenoh-c-specific>Zenoh-C Specific</h2><h3 id=shared-memory>Shared Memory</h3><p>Shared Memory subsystem has been heavily reworked and improved. The key functionality changes are:</p><ul><li>Buffer reference counting is now robust across abnormal process termination</li><li>Support plugging of user-defined SHM implementations</li><li>Dynamic SHM transport negotiation: Sessions are interoperable with any combination of SHM configuration and physical location</li><li>Support aligned allocations</li><li>Manual buffer invalidation</li><li>Buffer write access</li><li>Rich buffer allocation interface</li></ul><p>⚠️ Please note that SHM API is still unstable and will be improved in the future.</p><p><strong>SharedMemoryManager → SHMProvider + SHMProviderBackend</strong></p><ul><li>Zenoh 0.11.x</li></ul><div class=highlight><pre tabindex=0 style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#09f;font-style:italic>// size to dedicate to SHM manager
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span><span style=color:#069;font-weight:700>const</span> size_t size <span style=color:#555>=</span> <span style=color:#f60>1024</span> <span style=color:#555>*</span> <span style=color:#f60>1024</span>;
</span></span><span style=display:flex><span><span style=color:#09f;font-style:italic>// construct session id string
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span><span style=color:#069;font-weight:700>const</span> z_id_t id <span style=color:#555>=</span> z_info_zid(z_loan(s));
</span></span><span style=display:flex><span><span style=color:#078;font-weight:700>char</span> idstr[<span style=color:#f60>33</span>];
</span></span><span style=display:flex><span><span style=color:#069;font-weight:700>for</span> (<span style=color:#078;font-weight:700>int</span> i <span style=color:#555>=</span> <span style=color:#f60>0</span>; i <span style=color:#555>&lt;</span> <span style=color:#f60>16</span>; i<span style=color:#555>++</span>) {
</span></span><span style=display:flex><span>    sprintf(idstr <span style=color:#555>+</span> <span style=color:#f60>2</span> <span style=color:#555>*</span> i, <span style=color:#c30>&#34;%02x&#34;</span>, id.id[i]);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>idstr[<span style=color:#f60>32</span>] <span style=color:#555>=</span> <span style=color:#f60>0</span>;
</span></span><span style=display:flex><span><span style=color:#09f;font-style:italic>// create SHM manager
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span>zc_owned_shm_manager_t manager <span style=color:#555>=</span> zc_shm_manager_new(z_loan(s), idstr, size);
</span></span></code></pre></div><ul><li>Zenoh 1.0.0</li></ul><div class=highlight><pre tabindex=0 style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#09f;font-style:italic>// size to dedicate to SHM provider
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span><span style=color:#069;font-weight:700>const</span> size_t total_size <span style=color:#555>=</span> <span style=color:#f60>1024</span> <span style=color:#555>*</span> <span style=color:#f60>1024</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#09f;font-style:italic>// Difference: SHM provider now respects alignment
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span>z_alloc_alignment_t alignment <span style=color:#555>=</span> {<span style=color:#f60>0</span>};
</span></span><span style=display:flex><span>z_owned_memory_layout_t layout;
</span></span><span style=display:flex><span>z_memory_layout_new(<span style=color:#555>&amp;</span>layout, total_size, alignment);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#09f;font-style:italic>// create SHM provider
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span>z_owned_shm_provider_t provider;
</span></span><span style=display:flex><span>z_posix_shm_provider_new(<span style=color:#555>&amp;</span>provider, z_loan(layout));
</span></span></code></pre></div><p><strong>Buffer allocation</strong></p><ul><li>Zenoh 0.11.x</li></ul><div class=highlight><pre tabindex=0 style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#09f;font-style:italic>// buffer size
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span><span style=color:#069;font-weight:700>const</span> size_t alloc_size <span style=color:#555>=</span> <span style=color:#f60>1024</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#09f;font-style:italic>// allocate SHM buffer
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span>zc_owned_shmbuf_t shmbuf <span style=color:#555>=</span> zc_shm_alloc(<span style=color:#555>&amp;</span>manager, alloc_size);
</span></span><span style=display:flex><span><span style=color:#069;font-weight:700>if</span> (<span style=color:#555>!</span>z_check(shmbuf)) {
</span></span><span style=display:flex><span>    zc_shm_gc(<span style=color:#555>&amp;</span>manager);
</span></span><span style=display:flex><span>    shmbuf <span style=color:#555>=</span> zc_shm_alloc(<span style=color:#555>&amp;</span>manager, alloc_size);
</span></span><span style=display:flex><span>    <span style=color:#069;font-weight:700>if</span> (<span style=color:#555>!</span>z_check(shmbuf)) {
</span></span><span style=display:flex><span>        printf(<span style=color:#c30>&#34;Failed to allocate an SHM buffer, even after GCing</span><span style=color:#c30;font-weight:700>\n</span><span style=color:#c30>&#34;</span>);
</span></span><span style=display:flex><span>        exit(<span style=color:#555>-</span><span style=color:#f60>1</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li>Zenoh 1.0.0</li></ul><div class=highlight><pre tabindex=0 style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#09f;font-style:italic>// buffer size and alignment
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span><span style=color:#069;font-weight:700>const</span> size_t alloc_size <span style=color:#555>=</span> <span style=color:#f60>1024</span>;
</span></span><span style=display:flex><span><span style=color:#09f;font-style:italic>// Diffrence: allocation now respects alignment
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span>z_alloc_alignment_t alignment <span style=color:#555>=</span> {<span style=color:#f60>0</span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#09f;font-style:italic>// allocate SHM buffer
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span>z_buf_layout_alloc_result_t alloc;
</span></span><span style=display:flex><span><span style=color:#09f;font-style:italic>// Difference: there is a rich set of policies available to control
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic>// allocation behavior and handle allocation failures automatically
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span>z_shm_provider_alloc_gc(<span style=color:#555>&amp;</span>alloc, z_loan(provider), alloc_size, alignment);
</span></span><span style=display:flex><span><span style=color:#069;font-weight:700>if</span> (<span style=color:#555>!</span>z_check(alloc.buf)) {
</span></span><span style=display:flex><span>    printf(<span style=color:#c30>&#34;Failed to allocate an SHM buffer, even after GCing</span><span style=color:#c30;font-weight:700>\n</span><span style=color:#c30>&#34;</span>);
</span></span><span style=display:flex><span>    exit(<span style=color:#555>-</span><span style=color:#f60>1</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=ato-next><b>Next up</b>: <a href=/docs/migration_1.0/python/>Python</a></div></main></div></div><footer class="ato-footer text-muted"><div class="container-fluid p-6 p-md-5"><div class=row><div class=col-md-2><h5>Eclipse Incubation</h5><p><img src=../../../img/eclipse-incubation.png style=width:100px></p><p>Eclipse zenoh &trade; is an incubating project under the Eclipse Foundation.</p></div><div class=col-md-2><h5>More Information</h5><p><a href=https://www.eclipse.org/legal target=_blank>Legal</a></p><p><a href=https://www.eclipse.org/legal/privacy.php target=_blank>Privacy policy</a></p><p><a href=https://www.eclipse.org/legal/termsofuse.php target=_blank>Terms of use</a></p><p><a href=https://www.eclipse.org/legal/copyright.php target=_blank>Copyright</a></p><p><a href=https://www.eclipse.org/security/ target=_blank>Report a security issue</a></p><p><a href=https://www.eclipse.org/legal/epl-2.0/ target=_blank>Eclipse Public License 2.0</a></p><p><a href=https://www.apache.org/licenses/LICENSE-2.0 target=_blank>Apache License 2.0</a></p><p><a href=https://www.eclipse.org/ target=_blank>Eclipse Foundation</a></p></div><div class=col-md-2><h5>Sponsored by:</h5><p><a href=https://www.eclipse.org target=_blank><img src=../../../img/eclipse-foundation.svg style=width:120px></a></p><p><a href=https://zettascale.tech target=_blank><img src=../../../img/zettascale-dark.svg style=width:120px></a></p></div><div class=col-md-2><h5>Follow us</h5><p><a href=https://github.com/eclipse-zenoh/zenoh><i class="fa fa-github" aria-hidden=true></i>
GitHub</a></p><p><a href=https://discord.gg/vSDSpqnbkm><i class="fa fa fa-comments-o" aria-hidden=true></i>
Discord</a></p><p><a href=https://www.youtube.com/channel/UCslbiyiqgOAPMjCrPWIfQ5Q><i class="fa fa-youtube-play" aria-hidden=true></i> Youtube</a></p><p><a href=../../../docs/overview/what-is-zenoh><i class="fa fa-info-circle" aria-hidden=true></i> About</a></p></div><div class=col-md-2><p><img src=../../../img/zenoh-dragon-150x163.png style=width:45px></p><p>Eclipse zenoh &trade; is free, open source and always will be.</p><p>Copyright &copy 2022 Eclipse Foundation</p><p>Built with <a href=https://gohugo.io/ target=_blank>HUGO</a></p></div></div></div></footer><script src=https://ajax.googleapis.com/ajax/libs/jquery/3.1.1/jquery.min.js integrity=sha384-3ceskX3iaEnIogmQchP8opvBy3Mi7Ce34nWjpBIwVTHfGYWQS9jwHDVRnpKKHJg7 crossorigin=anonymous></script>
<script src=https://cdnjs.cloudflare.com/ajax/libs/tether/1.3.7/js/tether.min.js integrity=sha384-XTs3FgkjiBgo8qjEjBk0tGmf3wPrWtA6coPfQDfFEY8AnYJwjalXCiosYRBIBZX8 crossorigin=anonymous></script>
<script src=../../../js/bootstrap.min.js></script>
<script src=../../../js/highlight.min.js></script>
<script>$(function(){$("pre code").each(function(e,t){if(t.className.indexOf("language-rust")>=0){for(var s="",n=t.textContent.split(`
`),e=0;e<n.length;e++){if(n[e].indexOf("# ")==0||n[e]=="#")continue;s+=n[e].trimRight()+`
`}t.textContent=s.replace(/\n\n\n/g,`

`).trimRight()}hljs.highlightBlock(t)})})</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-PBD6MS51QL"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-PBD6MS51QL",{anonymize_ip:!1})}</script></body></html>